---
title: "Model_v1"
output: html_document
---

#Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Close graphics and clear local memory
graphics.off()
rm(list=ls())

#load libraries
library(ggplot2)
library(plyr)
library(data.table)
library(AER)
library(sandwich)
library(foreign)
library(rmarkdown)
library(lme4)
library(lmerTest)
library(lfe)
library(googlesheets4)

#load data
cover.climate=as.data.table(read.csv("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis/cover_climate.csv",header = T)) 

transect.master=as.data.table(read.csv("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis/Transect_master_V2.csv",header = T)) #use V2 after data issue

#indices.yearly=as.data.table(read.csv("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis/Indices_Yearly.csv",header = T)) 

#indices.monthly=as.data.table(read.csv("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis/Indices_Monthly.csv",header = T)) 

options(max.print = 1000) #set print limit for expediency 

#Load in list of species identified to be of particular importance from google sheets
imp.spec.url = as_sheets_id('https://docs.google.com/spreadsheets/d/1QrL-ToXXgGIo8OJa9QieW102y1oFx6ljyM7wSa98KuU/edit?usp=sharing')
imp.i.spec.dt = as.data.table(read_sheet(imp.spec.url, sheet = "Invasives", col_names = T, na = "NA", trim_ws = T))
imp.i.spec = imp.i.spec.dt[,.(ID,`Marissa Concern`,`Daren Concern`, `Sara Concern`, `Hugh Concern`)][!(is.na(`Marissa Concern`) & is.na(`Daren Concern`) & is.na(`Sara Concern`) & is.na(`Hugh Concern`)),ID]
imp.n.spec.dt = as.data.table(read_sheet(imp.spec.url, sheet = "Natives ", col_names = T, na = "NA", trim_ws = T))
imp.n.spec = imp.n.spec.dt[,.(ID,`Marissa Concern`,`Daren Concern`, `Sara Concern`, `Hugh Concern`)][!(is.na(`Marissa Concern`) & is.na(`Daren Concern`) & is.na(`Sara Concern`) & is.na(`Hugh Concern`)),ID]

#Not all species of concern will have enough data. Subset this list by including species that have panel data
imp.spec = c(imp.i.spec, imp.n.spec)
imp.spec = cover.climate[SpeciesID %in% imp.spec,.N, by = .(SpeciesID,TransectID)][,max(N),by = .(SpeciesID)][V1>1,SpeciesID]


#relevel cover factors so it is relative to rest as y intercept
levels(cover.climate$Action)
cover.climate$Action = factor(cover.climate$Action, levels = c("Rest","Burn","Graze","Combo",""))

#Factorize TransectID, SITE_ID, ObsCode,and Year 
cover.climate$Year = as.factor(cover.climate$Year)
cover.climate$TransectID = as.factor(cover.climate$TransectID)
cover.climate$MGMTUNIT_I = as.factor(cover.climate$MGMTUNIT_I)
cover.climate$SITE_ID = as.factor(cover.climate$SITE_ID)
cover.climate$ObsCode = as.factor(cover.climate$ObsCode)

#Remove Transects with blanks for Action, I don't think I will need this for the lagged models
cover.climate = cover.climate[!Action=="",]

#Because we have limited data, for now remove combo and grazing, so that the fixed model can compile.
cover.climate = cover.climate[!(Action=="Graze" | Action=="Combo"),]

#Both the fixed effect and lagged effect models require complete panel data, so at least two years of obersvations per measurement unit. With the full data I should be able to subset by Delta=1, but with limited climate data I will need to fix this.
z = c(cover.climate[,length(unique(Year)),by = TransectID][V1>1,TransectID])
cover.climate = cover.climate[!(TransectID %in% z),]

#Deal with missing species traits and duplicate issues
cover.climate[is.na(Legume),Legume:=0]
cover.climate[,':='(leg.f.tran=max(leg.f.tran), leg.f.tran.lag = max(leg.f.tran.lag, na.rm = T)), by = .(Year, TransectID)]



#Create sub-cover files to match the model analysis. E.g. transect-level analysis should not include species rows, that would create too many replication ir_tran values

tran.dt       = unique(cover.climate[,.(Year,TransectID,SITE_ID,MGMTUNIT_I,Action,Delta,StartLat,StartLong,Long.Cat,Lat.Cat,ManUnitAcres,ObsCode,
                                          VOR,VOR.lag, Litter, Litter.lag, sr_tran,sr_tran.lag, leg.f.tran, leg.f.tran.lag,
                                        
                                          nr_tran, nf.tran, meanDI.n.tran.2, change_nf.tran, indf.n.tran, change_indf.n.tran,
                                          nr_tran.lag, nf.tran.lag, meanDI.n.tran.2.lag, indf.n.tran.lag,
                                          rel.cov.n.1.1,rel.cov.n.1.2, rel.cov.n.2, rel.cov.n.3, rel.cov.n.4,
                                          rel.cov.n.1.1.lag,rel.cov.n.1.2.lag, rel.cov.n.2.lag, rel.cov.n.3.lag, rel.cov.n.4.lag,
                                          ind_nr_tran,ind_n1r_tran, ind_n2r_tran, ind_nr_tran.lag, ind_n1r_tran.lag, ind_n2r_tran.lag,
                                          indf.n1.tran, indf.n2.tran, indf.n1.tran.lag, indf.n2.tran.lag,
                                          rel.cov.ind.n.2, rel.cov.ind.n1.2, rel.cov.ind.n2.2, rel.cov.ind.n.2.lag, rel.cov.ind.n1.2.lag, rel.cov.ind.n2.2.lag,
                                          meanDI.ind.n.tran.2, meanDI.ind.n1.tran.2, meanDI.ind.n2.tran.2, meanDI.ind.n.tran.2.lag, meanDI.ind.n1.tran.2.lag, meanDI.ind.n2.tran.2.lag,
                                        
                                          ir_tran,if.tran,meanDI.i.tran.2, change_if.tran,indf.i.tran, change_indf.i.tran,
                                          ir_tran.lag,if.tran.lag ,meanDI.i.tran.2.lag, indf.i.tran.lag,
                                          rel.cov.i.1.1,rel.cov.i.1.2,rel.cov.i.2,rel.cov.i.3,rel.cov.i.4,
                                          rel.cov.i.1.1.lag,rel.cov.i.1.2.lag, rel.cov.i.2.lag, rel.cov.i.3.lag ,rel.cov.i.4.lag,
                                          ind_ir_tran,ind_i1r_tran, ind_i2r_tran, ind_ir_tran.lag, ind_i1r_tran.lag, ind_i2r_tran.lag,
                                          indf.i1.tran, indf.i2.tran, indf.i1.tran.lag, indf.i2.tran.lag,
                                          rel.cov.ind.i.2, rel.cov.ind.i1.2, rel.cov.ind.i2.2, rel.cov.ind.i.2.lag, rel.cov.ind.i1.2.lag, rel.cov.ind.i2.2.lag,
                                          meanDI.ind.i.tran.2, meanDI.ind.i1.tran.2, meanDI.ind.i2.tran.2, meanDI.ind.i.tran.2.lag, meanDI.ind.i1.tran.2.lag, meanDI.ind.i2.tran.2.lag,
                                        
                                          txx,tn90p, tx90p,rx5.w,rx5.sp,rx5.sum,rx5.y,fd,gsl,wsdi,csdi,sdii,cdd,cwd,prcpt,
                                          txx.lag,tn90p.lag, tx90p.lag,rx5.w.lag,rx5.sp.lag,rx5.sum.lag,rx5.y.lag, 
                                              fd.lag,gsl.lag,wsdi.lag,csdi.lag,sdii.lag,cdd.lag,cwd.lag,prcpt.lag)])

#U don't foresee doing a management analysis, but in case here is an un-updated dt
mgmt.dt       = unique(cover.climate[,.(Year,TransectID,SITE_ID,MGMTUNIT_I, Action, Delta,StartLat,StartLong,Long.Cat,Lat.Cat,ManUnitAcres,ObsCode,
                                          VOR, Litter, sr_mgmt,
                                          VOR.lag, Litter.lag, sr_tran.lag,
                                          nr_mgmt, nf.mgmt, change_nf.mgmt,indf.n.mgmt, change_indf.n.mgmt,
                                                   nf.mgmt.lag,indf.n.mgmt.lag, 
                                          ir_mgmt,if.mgmt, change_if.mgmt,indf.i.mgmt, change_indf.i.mgmt,
                                          ir_mgmt.lag,if.mgmt.lag,indf.i.mgmt.lag,  
                                          txx,tn90p, tx90p,rx5.w,rx5.sp,rx5.sum,rx5.y,fd,gsl,wsdi,csdi,sdii,cdd,cwd,prcpt,
                                          txx.lag,tn90p.lag, tx90p.lag,rx5.w.lag,rx5.sp.lag,rx5.sum.lag,rx5.y.lag, 
                                              fd.lag,gsl.lag,wsdi.lag,csdi.lag,sdii.lag,cdd.lag,cwd.lag,prcpt.lag)])
#update this as needed
group.dt       = unique(cover.climate[,.(Year,TransectID,SITE_ID,MGMTUNIT_I,Action,Delta,StartLat,StartLong,Long.Cat,Lat.Cat,ManUnitAcres,ObsCode,
                                          VOR, Litter, sr_tran, VOR.lag, Litter.lag, sr_tran.lag,
                                          Duration,Type, Photopath,Legume, Range, Distribution, Native.Status, Ind.class, Indicator, Season,
                                         
                                          r.T.dur, r.T.dur.lag, r.T.type,r.T.type.lag, r.T.photo, r.T.photo.lag, r.T.range,r.T.range.lag,
                                            r.T.dist,r.T.dist.lag, r.T.season, r.T.season.lag,
                                          f.T.dur,f.T.dur.lag,f.T.type,f.T.type.lag, f.T.photo, f.T.photo.lag,
                                            f.T.range, f.T.range.lag, f.T.dist, f.T.dist.lag, f.T.season, f.T.season.lag,
                                          rel.cov.2.dur, rel.cov.2.dur.lag, rel.cov.2.type, rel.cov.2.type.lag, rel.cov.2.photo, rel.cov.2.photo.lag, 
                                            rel.cov.2.range, rel.cov.2.range.lag, rel.cov.2.dist, rel.cov.2.dist.lag, rel.cov.2.season, rel.cov.2.season.lag,
                                          #meanDI.2.dur, meanDI.2.dur.lag, meanDI.2.type, meanDI.2.type.lag, meanDI.2.photo, meanDI.2.photo.lag, 
                                          #meanDI.2.range, meanDI.2.range.lag, meanDI.2.dist, meanDI.2.dist.lag, meanDI.2.season, meanDI.2.season.lag,
                                         
                                          r.ind.dur, f.ind.dur, rel.cov.2.ind.dur, meanDI.2.ind.dur,
                                          r.indlvl.dur,f.indlvl.dur, rel.cov.2.indlvl.dur, meanDI.2.indlvl.dur,
                                          r.ind.type, f.ind.type, rel.cov.2.ind.type, meanDI.2.ind.type,
                                          r.indlvl.type,f.indlvl.type, rel.cov.2.indlvl.type, meanDI.2.indlvl.type,
                                          r.ind.season, f.ind.season, rel.cov.2.ind.season, meanDI.2.ind.season,
                                          r.indlvl.season, f.indlvl.season, rel.cov.2.indlvl.season, meanDI.2.indlvl.season,
                                          r.ind.photo, f.ind.photo, rel.cov.2.ind.photo, meanDI.2.ind.photo,
                                          r.indlvl.photo,f.indlvl.photo, rel.cov.2.indlvl.photo, meanDI.2.indlvl.photo,
                                          r.ind.range, f.ind.range, rel.cov.2.ind.range, meanDI.2.ind.range,
                                          r.indlvl.range,f.indlvl.range, rel.cov.2.indlvl.range, meanDI.2.indlvl.range,
                                          r.ind.dist, f.ind.dist, rel.cov.2.ind.dist, meanDI.2.ind.dist,
                                          r.indlvl.dist,f.indlvl.dist, rel.cov.2.indlvl.dist, meanDI.2.indlvl.dist,
                                         
                                          nr_tran, nf.tran, meanDI.n.tran.2, change_nf.tran, indf.n.tran, change_indf.n.tran,
                                          nr_tran.lag, nf.tran.lag, meanDI.n.tran.2.lag, indf.n.tran.lag,
                                          rel.cov.n.1.1,rel.cov.n.1.2, rel.cov.n.2, rel.cov.n.3, rel.cov.n.4,
                                          rel.cov.n.1.1.lag,rel.cov.n.1.2.lag, rel.cov.n.2.lag, rel.cov.n.3.lag, rel.cov.n.4.lag,
                                          ind_nr_tran,ind_n1r_tran, ind_n2r_tran, ind_nr_tran.lag, ind_n1r_tran.lag, ind_n2r_tran.lag,
                                          indf.n1.tran, indf.n2.tran, indf.n1.tran.lag, indf.n2.tran.lag,
                                          rel.cov.ind.n.2, rel.cov.ind.n1.2, rel.cov.ind.n2.2, rel.cov.ind.n.2.lag, rel.cov.ind.n1.2.lag, rel.cov.ind.n2.2.lag,
                                          meanDI.ind.n.tran.2, meanDI.ind.n1.tran.2, meanDI.ind.n2.tran.2, meanDI.ind.n.tran.2.lag, meanDI.ind.n1.tran.2.lag, meanDI.ind.n2.tran.2.lag,
                                        
                                          ir_tran,if.tran,meanDI.i.tran.2, change_if.tran,indf.i.tran, change_indf.i.tran,
                                          ir_tran.lag,if.tran.lag ,meanDI.i.tran.2.lag, indf.i.tran.lag,
                                          rel.cov.i.1.1,rel.cov.i.1.2,rel.cov.i.2,rel.cov.i.3,rel.cov.i.4,
                                          rel.cov.i.1.1.lag,rel.cov.i.1.2.lag, rel.cov.i.2.lag, rel.cov.i.3.lag ,rel.cov.i.4.lag,
                                          ind_ir_tran,ind_i1r_tran, ind_i2r_tran, ind_ir_tran.lag, ind_i1r_tran.lag, ind_i2r_tran.lag,
                                          indf.i1.tran, indf.i2.tran, indf.i1.tran.lag, indf.i2.tran.lag,
                                          rel.cov.ind.i.2, rel.cov.ind.i1.2, rel.cov.ind.i2.2, rel.cov.ind.i.2.lag, rel.cov.ind.i1.2.lag, rel.cov.ind.i2.2.lag,
                                          meanDI.ind.i.tran.2, meanDI.ind.i1.tran.2, meanDI.ind.i2.tran.2, meanDI.ind.i.tran.2.lag, meanDI.ind.i1.tran.2.lag, meanDI.ind.i2.tran.2.lag, 
                                         
                                         txx,tn90p, tx90p,rx5.w,rx5.sp,rx5.sum,rx5.y,fd,gsl,wsdi,csdi,sdii,cdd,cwd,prcpt,
                                          txx.lag,tn90p.lag, tx90p.lag,rx5.w.lag,rx5.sp.lag,rx5.sum.lag,rx5.y.lag, 
                                              fd.lag,gsl.lag,wsdi.lag,csdi.lag,sdii.lag,cdd.lag,cwd.lag,prcpt.lag)])

#########This is for checking how to break this out so I don't have duplicate values when I model, can remove later if needed
#unique(group.dt[TransectID==57 & Year==2010,.(Native.Status,Duration,Ind.class, Indicator,r.T.dur,r.T.dur.lag,f.T.dur,f.T.dur.lag,rel.cov.2.dur,meanDI.2.dur)])

#unique(group.dt[TransectID==57 & Year==2010,.(Native.Status,Duration,Type,r.T.dur,r.T.dur.lag,f.T.dur,f.T.dur.lag,rel.cov.2.dur,meanDI.2.dur)])

#unique(group.dt[TransectID==57 & Year==2011,.(Native.Status,Duration,Type,Photopath,Legume,Range,Distribution,r.T.dur,r.T.dur.lag,f.T.dur,f.T.dur.lag,rel.cov.2.dur,meanDI.2.dur,r.T.type,f.T.type,rel.cov.2.type,meanDI.2.type,r.T.photo,f.T.photo,rel.cov.2.photo,meanDI.2.photo,r.T.leg,f.T.leg,rel.cov.2.leg,meanDI.2.leg,r.T.range,f.T.range,rel.cov.2.range,meanDI.2.range,r.T.dist,f.T.dist,rel.cov.2.dist,meanDI.2.dist)])

#group.dt[TransectID==57 & Year==2010,.(length(unique(Duration))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.dur,r.T.dur.lag,f.T.dur,Native.Status,Duration)])[,length(Native.Status)]

#group.dt[TransectID==57 & Year==2010,.(length(unique(Type))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.type,r.T.type.lag,Native.Status,Type)])[,length(Native.Status)]

#group.dt[TransectID==57 & Year==2010,.(length(unique(Photopath))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.photo,r.T.photo.lag,Native.Status,Photopath)])[,length(Native.Status)]

#group.dt[TransectID==57 & Year==2010,.(length(unique(Legume))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.leg,r.T.leg.lag,Native.Status,Legume)])[,length(Native.Status)]

#[TransectID==57 & Year==2010,.(length(unique(Range))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.range,r.T.range.lag,Native.Status,Range)])[,length(Native.Status)]

#group.dt[TransectID==57 & Year==2010,.(length(unique(Distribution))),by=Native.Status][,sum(V1)]
#unique(group.dt[TransectID==57 & Year==2010,.(r.T.dist,r.T.dist.lag,Native.Status,Distribution)])[,length(Native.Status)]
#########

variables = colnames(group.dt) 

group.names = as.data.table(cbind(as.character(expression(
                                            dur.dt, ind.dur.dt, indlvl.dur.dt, type.dt,ind.type.dt, indlvl.type.dt,photo.dt, ind.photo.dt, indlvl.photo.dt, 
                                            range.dt, ind.range.dt, indlvl.range.dt, dist.dt, ind.dist.dt, indlvl.dist.dt, season.dt, ind.season.dt, indlvl.season.dt)),
                                
                                  as.character(expression(
                                            dur.dt.lag, ind.dur.dt.lag, indlvl.dur.dt.lag, type.dt.lag,ind.type.dt.lag, indlvl.type.dt.lag, 
                                            photo.dt.lag, ind.photo.dt.lag, indlvl.photo.dt.lag, range.dt.lag, ind.range.dt.lag, indlvl.range.dt.lag, 
                                            dist.dt.lag, ind.dist.dt.lag, indlvl.dist.dt.lag, season.dt.lag, season.ind.dt.lag, season.indlvl.dt.lag)),
                                
                                as.character(expression(
                                            i.dur.dt, i.ind.dur.dt, i.indlvl.dur.dt, i.type.dt, i.ind.type.dt, i.indlvl.type.dt,i.photo.dt, i.ind.photo.dt, i.indlvl.photo.dt,
                                            i.range.dt, i.ind.range.dt, i.indlvl.range.dt, i.dist.dt, i.ind.dist.dt, i.indlvl.dist.dt,
                                            i.season.dt, i.season.ind.dt, i.season.indlvl.dt)),
                                
                                 as.character(expression(
                                            i.dur.dt.lag, i.ind.dur.dt.lag, i.indlvl.dur.dt.lag, i.type.dt.lag, i.ind.type.dt.lag, i.indlvl.type.dt.lag,
                                            i.photo.dt.lag, i.ind.photo.dt.lag, i.indlvl.photo.dt.lag, i.range.dt.lag, i.ind.range.dt.lag, i.indlvl.range.dt.lag, 
                                            i.dist.dt.lag, i.ind.dist.dt.lag, i.indlvl.dist.dt.lag, i.season.dt.lag, i.season.ind.dt.lag, i.season.indlvl.dt.lag )),
                                
                                as.character(expression(
                                            n.dur.dt, n.ind.dur.dt, n.indlvl.dur.dt, n.type.dt, n.ind.type.dt, n.indlvl.type.dt, n.photo.dt, n.ind.photo.dt, n.indlvl.photo.dt,
                                            n.range.dt, n.ind.range.dt, n.indlvl.range.dt, n.dist.dt, n.ind.dist.dt, n.indlvl.dist.dt,
                                            n.season.dt, n.season.ind.dt, n.season.indlvl.dt)),
                                 
                                as.character(expression(
                                            n.dur.dt.lag, n.ind.dur.dt.lag, n.indlvl.dur.dt.lag, n.type.dt.lag, n.ind.type.dt.lag, n.indlvl.type.dt.lag,
                                            n.photo.dt.lag, n.ind.photo.dt.lag, n.indlvl.photo.dt.lag,n.range.dt.lag, n.ind.range.dt.lag, n.indlvl.range.dt.lag, 
                                            n.dist.dt.lag, n.ind.dist.dt.lag, n.indlvl.dist.dt.lag, n.season.dt.lag, n.season.ind.dt.lag, n.season.indlvl.dt.lag)),
                                
                                rep(as.character(expression(
                                            Duration, Type, Photopath, Range, Distribution, Season)),each = 3), #repeat 3 times because 3 measures per group with indicator metric added
                                
                                matrix(as.character(expression(
                                            r.T.dur, r.T.dur.lag, f.T.dur,f.T.dur.lag,rel.cov.2.dur, rel.cov.2.dur.lag,meanDI.2.dur, meanDI.2.dur.lag,
                                            r.ind.dur, r.ind.dur.lag, f.ind.dur, f.ind.dur.lag, rel.cov.2.ind.dur, rel.cov.2.ind.dur.lag, meanDI.2.ind.dur,meanDI.2.ind.dur.lag,
                                            r.indlvl.dur,r.indlvl.dur.lag,f.indlvl.dur,f.indlvl.dur.lag, rel.cov.2.indlvl.dur,rel.cov.2.indlvl.dur.lag, 
                                            meanDI.2.indlvl.dur,meanDI.2.indlvl.dur.lag,
                                          
                                            r.T.type, r.T.type.lag, f.T.type,f.T.type.lag,rel.cov.2.type, rel.cov.2.type.lag,meanDI.2.type, meanDI.2.type.lag,
                                            r.ind.type, r.ind.type.lag, f.ind.type, f.ind.type.lag, rel.cov.2.ind.type, rel.cov.2.ind.type.lag, meanDI.2.ind.type,meanDI.2.ind.type.lag,
                                            r.indlvl.type,r.indlvl.type.lag,f.indlvl.type,f.indlvl.type.lag, rel.cov.2.indlvl.type,rel.cov.2.indlvl.type.lag, 
                                            meanDI.2.indlvl.type,meanDI.2.indlvl.type.lag,
                                            
                                            r.T.photo, r.T.photo.lag, f.T.photo,f.T.photo.lag,rel.cov.2.photo, rel.cov.2.photo.lag,meanDI.2.photo, meanDI.2.photo.lag,
                                            r.ind.photo, r.ind.photo.lag, f.ind.photo, f.ind.photo.lag, rel.cov.2.ind.photo, rel.cov.2.ind.photo.lag, 
                                            meanDI.2.ind.photo,meanDI.2.ind.photo.lag,r.indlvl.photo,r.indlvl.photo.lag,f.indlvl.photo,f.indlvl.photo.lag, 
                                            rel.cov.2.indlvl.photo,rel.cov.2.indlvl.photo.lag, meanDI.2.indlvl.photo,meanDI.2.indlvl.photo.lag,
                                            
                                            r.T.range, r.T.range.lag, f.T.range,f.T.range.lag,rel.cov.2.range, rel.cov.2.range.lag,meanDI.2.range, meanDI.2.range.lag,
                                            r.ind.range, r.ind.range.lag, f.ind.range, f.ind.range.lag, rel.cov.2.ind.range, rel.cov.2.ind.range.lag, 
                                            meanDI.2.ind.range,meanDI.2.ind.range.lag, r.indlvl.range,r.indlvl.range.lag,f.indlvl.range,f.indlvl.range.lag, 
                                            rel.cov.2.indlvl.range,rel.cov.2.indlvl.range.lag,meanDI.2.indlvl.range,meanDI.2.indlvl.range.lag,
                                            
                                            r.T.dist, r.T.dist.lag, f.T.dist,f.T.dist.lag,rel.cov.2.dist, rel.cov.2.dist.lag,meanDI.2.dist, meanDI.2.dist.lag,
                                            r.ind.dist, r.ind.dist.lag, f.ind.dist, f.ind.dist.lag, rel.cov.2.ind.dist, rel.cov.2.ind.dist.lag, meanDI.2.ind.dist,meanDI.2.ind.dist.lag,
                                            r.indlvl.dist,r.indlvl.dist.lag,f.indlvl.dist,f.indlvl.dist.lag, rel.cov.2.indlvl.dist,rel.cov.2.indlvl.dist.lag, 
                                            meanDI.2.indlvl.dist,meanDI.2.indlvl.dist.lag,
                                            
                                            r.T.season, r.T.season.lag, f.T.season,f.T.season.lag,rel.cov.2.season, rel.cov.2.season.lag,meanDI.2.season, meanDI.2.season.lag,
                                            r.ind.season, r.ind.season.lag, f.ind.season, f.ind.season.lag, rel.cov.2.ind.season, rel.cov.2.ind.season.lag,
                                            meanDI.2.ind.season,meanDI.2.ind.season.lag, r.indlvl.season,r.indlvl.season.lag,f.indlvl.season,f.indlvl.season.lag,
                                            rel.cov.2.indlvl.season,rel.cov.2.indlvl.season.lag, meanDI.2.indlvl.season,meanDI.2.indlvl.season.lag)),
                                       
                                      ncol =8, byrow = T),
                                rep("Year",times=18),
                                rep("TransectID",times=18),
                                rep("Native.Status",times=18),
                                rep("Ind.class", times = 18),
                                rep("Indicator", times = 18)
                    ))

#Create loop to make specific group dt's....HUGH makesure to include a subset for T1 only at the indlvl 
group.list = list()
#name.list = list() For checking

#All
for (k in 1:3){
    for (i in 1:(group.names[,length(V1)]/3)){
      z = as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),.SD, .SDcols=c(7:(ncol(group.names)-3),ncol(group.names)-3+k)])
      #name.list[[k + ((i-1)*(group.names[,length(V1)]/6))]] = z
      group.list[[k + ((i-1)*(group.names[,length(V1)]/6))]] = merge(tran.dt,unique(cover.climate[,z,with=FALSE] 
        [!(is.na(eval(parse(text=(as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),V10])))))),]),by=c('Year','TransectID'))
  }
}

#All lag
for (i in 1:group.names[,length(V1)]) {
  group.list[[i+group.names[,length(V1)]]] = group.list[[i]][!is.na(eval(parse(text=(as.character(group.names[i,V9]))))),]
  }


#Invasive
  for (k in 1:3){
    for (i in 1:(group.names[,length(V1)]/3)){
      z = as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),.SD, .SDcols=c(7:(ncol(group.names)-3),ncol(group.names)-3+k)])
      group.list[[k + ((i-1)*(group.names[,length(V1)]/6)) + (group.names[,length(V1)]*2)]] =
        merge(tran.dt,unique(cover.climate[Native.Status=="I",z,with=FALSE] 
        [!(is.na(eval(parse(text=(as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),V10])))))),]),by=c('Year','TransectID'))
      #name.list[[k + ((i-1)*(group.names[,length(V1)]/6)) + (group.names[,length(V1)]*1)]] = z
  }
}

#Subset for Indicator = I1
  for (i in 1:(group.names[,length(V1)]/3)){
    group.list[[(group.names[,length(V1)]*2) + (i*3)]] = group.list[[(group.names[,length(V1)]*2) + (i*3)]][Indicator=="I1",]
  }

#Invasive Lag
for (i in 1:group.names[,length(V1)]) {
  group.list[[i+(group.names[,length(V1)]*3)]] = group.list[[i+(group.names[,length(V1)]*2)]][!is.na(eval(parse(text=(as.character(group.names[i,V9]))))),]
}

#Native
  for (k in 1:3){
    for (i in 1:(group.names[,length(V1)]/3)){
      z = as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),.SD, .SDcols=c(7:(ncol(group.names)-3),ncol(group.names)-3+k)])
      group.list[[k + ((i-1)*(group.names[,length(V1)]/6)) + (group.names[,length(V1)]*4)]] = merge(tran.dt,unique(cover.climate[Native.Status=="N",z,with=FALSE] 
        [!(is.na(eval(parse(text=(as.character(group.names[k + ((i-1)*(group.names[,length(V1)]/6)),V10])))))),]),by=c('Year','TransectID'))
      #name.list[[k + ((i-1)*(group.names[,length(V1)]/6)) + (group.names[,length(V1)]*2)]] = z
  }
}

#Subset for Indicator = N1
  for (i in 1:(group.names[,length(V1)]/3)){
    group.list[[(group.names[,length(V1)]*4) + (i*3)]] = group.list[[(group.names[,length(V1)]*4) + (i*3)]][Indicator=="N1",]
  }

#Native Lag
for (i in 1:group.names[,length(V1)]) {
  group.list[[i+(group.names[,length(V1)]*5)]] = group.list[[i+(group.names[,length(V1)]*4)]][!is.na(eval(parse(text=(as.character(group.names[i,V9]))))),]
}

#Name the list elements
names(group.list) = c(group.names$V1,group.names$V2, group.names$V3,group.names$V4,group.names$V5, group.names$V6)


#Something is off with the naming of the list, write a loop to check for errors
naming.check.data = c()
for (i in 1:length(group.list)){
  zz = names(group.list[[i]])[134]
  naming.check.data = c(naming.check.data, zz)
}

naming.check = cbind(names(group.list), naming.check.data)

#Not averaged at transcet level
i.species.dt    = cover.climate[Native.Status=="I" ,]
n.species.dt    = cover.climate[Native.Status=="N" ,]
ind.i.species.dt = cover.climate[Ind.class == "I" ,]
ind.n.species.dt = cover.climate[Ind.class == "N" ,]
ind.i1.species.dt = cover.climate[Indicator=="I1" ,]
ind.n1.species.dt = cover.climate[Indicator=="N1"  ,]
all.species.dt  = cover.climate

#Now create lagged versions of these dt ^ which remove NAs from key areas...I care about abundance metrics and indices, selecting one of each should remove the other NAs as well
tran.dt.lag = na.omit(tran.dt, cols = c("ir_tran.lag","gsl"))
#mgmt.dt.lag = na.omit(mgmt.dt, cols = c("ir_mgmt.lag","gsl"))
i.species.dt.lag = na.omit(i.species.dt, cols = c("Freq.T.lag","gsl"))
n.species.dt.lag    = na.omit(n.species.dt, cols = c("Freq.T.lag","gsl"))
all.species.dt.lag    = na.omit(all.species.dt, cols = c("Freq.T.lag","gsl"))


###Define Functions

#Define Log Function
ihs = function(x) {
  return(log(x + sqrt(x^2+1)))
}
# v.s. log(x+1) <- is defined for a negative x.

#Function which allows me to more elegantly include characters from a vector in loops
eval.as = function(x) {
  return(parse(text=(as.character(x))))
}
``` 

#Index Key:
Yearly:
FD -Annual count of days when TN (daily minimum temperature) < 0°C  
SU - Annual count of days when TX (daily maximum temperature) > 25°C.  
ID - Annual count of days when TX (daily maximum temperature) < 0 °C.  
TR - Annual count of days when TN (daily minimum temperature) > 20 °C.   
GSL - Growing Season length. Annual* count between the first span of at least 6 days with daily mean temperature TG >5 °C and the first span after July 1st (Jan 1st in SH) of 6 days with TG <5 °C.  
WSDI - Warm spell duration index: annual count of days with at least 6 consecutive days when TX > 90th percentile  
CSDI - Cold spell duration index: annual count of days with at least 6 consecutive days when TN < 10th percentile  
SDII - Simple precipitation intensity index  
R10mm - Annual count of days when PRCP ≥ 10mm  
R20mm - Annual count of days when PRCP ≥ 20mm  
Rnnmm - Annual count of days when PRCP ≥ nn mm, where nn is a user-defined threshold  
CDD - Maximum length of dry spell: maximum number of consecutive days with RR < 1mm  
CWD - Maximum length of wet spell: maximum number of consecutive days with RR ≥ 1mm  
R95p - Annual total PRCP when RR > 95th percentile  
R99p - Annual total PRCP when RR > 99th percentile  
PRCPTOT - Annual total precipitation on wet days  

Monthly:
TXx - Monthly maximum value of daily maximum temperature  
TNx - Monthly maximum value of daily minimum temperature  
TXn - Monthly minimum value of daily minimum temperature  
TNn - Monthly minimum value of daily minimum temperature  
TN10p - Percentage of days when TN < 10th percentile  
TX10p - Percentage of days when TX < 10th percentile  
TN90p - Percentage of days when TN > 90th percentile  
TX90p - Percentage of days when TX > 90th percentile
DTR - Daily temperature range  
Rx1day - Monthly maximum 1-day precipitation  
Rx5day - Monthly maximum consecutive 5-day precipitation  


##Models Set 1  - Invasive Species
Create a linear model to explain invasive species values.

Dependent Variable
A = Invasive abundance at transect; either:
  •	Invasive Richness
  •	Invasive Frequency
  •	Cumulative invasive cover
  •	Dominance Indicator 
 
Independent Variables
C = Climate indices 
  •	Yearly
  •	Monthly
O = Observer 
  •	Coded observer factor
M = Management action
  •	Categorical factor 
D = Management Timing
  •	Day of the Year
  •	Categorical Season description
T = Transect
  •	Factorized Transect ID
Y = Year
  •	Factorized year of observation and management action

put in transect as a factor

Other time-dependent independent variables to consider: transect diversity/SR, particularly native sr; legume presence; transect productivity (VOR)
    

#Model Formula
Aji = β0 + β1Mij + β2Dij + β3Cij + β4Tij+ β5Yij+ β6Oij  + β7MDCit + Vio + Vi1Tij + Vi2Yij + Vi3Oit + eij

Where:
ij =  per transect measurement per year
e = random unobserved error
β0 = Per transect intercept



#Exploratory Models

```{r Invasives-lm}
#Start with modeling invasive abundance

options(max.print = 60)

#run one model without climate
lm.ir.1 = lm(data = tran.dt , formula = ir_tran ~ Action + ObsCode + TransectID )
summary(lm.ir.1)

lm.if.1 = lm(data = tran.dt , formula = if.tran ~ Action + ObsCode + TransectID )
summary(lm.if.1)

lm.di.i.1 = lm(data = tran.dt , formula = meanDI.I_tran ~ Action + ObsCode + TransectID )
summary(lm.di.i.1)

par(mfrow=c(2,2))
plot(lm.ir.1)

plot(lm.if.1)

plot(lm.di.i.1)


#Consider correlations between indices and inputting multiple in one model. Scatter plot between independent variables
library(GGally)
x=tran.dt[,.(Action,ObsCode,TransectID)]
ggpairs(x)


```

####Mixed and lagged-effects multivariate models

The above models are simple linear multivariable linear regressions, but I need to treat variable according to whether they are random or fixed effects.

Create a mixed effect model for each metric of invasive abundance (richness, frequency, total relative cover, and dominance) and for each climate index of interest.




Hugh - check to make sure I'm not using zero values accidentally


#Cluster Analsis
Selecting grouping for species is hard to do a priori. Use the response data to draw clustering correlations between species to define/justify grouping selection.

First attempt - run agglomerative hierarchical clustering analysis
```{r clustering}
#invasive data preparation - need rows as observations and columns as variables, no NAs, all scaled
#Create data tables that: preserve each species (creates unique id to avoid duplicates); averages species value (maybe by year)

library(cluster)
library(purrr)
library(factoextra)

#All species data - the idea here is to see if species themselve are grouping similarly
ic.all.df = as.data.frame(cover.climate[Native.Status=="I",.(SpeciesID,Freq.T,cov.2.T,DI.T.2,change_f.tran,change_cov.2.T)])
ic.all.df = na.omit(ic.all.df)
is.count = length(unique(ic.all.df$SpeciesID)) #use this late on for clustering
species = as.character(ic.all.df$SpeciesID)
ic.all.df$SpeciesID = as.character(ic.all.df$SpeciesID)
rownames(ic.all.df) = make.names(ic.all.df[[1]], unique = T)
ic.all.df$SpeciesID <- NULL
ic.all.df = scale(ic.all.df)

#Agglomerative hierarchical clustering
# Compute with agnes 
hc1 <- agnes(ic.all.df, method = "complete")
# Agglomerative coefficient
hc1$ac

# vector of methods to compare
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")
 
# function to compute coefficient
ac <- function(x) {
  agnes(ic.all.df, method = x)$ac
}
#map_dbl(m, ac)      

#Ward’s method gets us the highest agglomerative coefficient. Let us look at its dendogram.
#hc2 <- agnes(ic.all.df, method = "ward")
#pltree(hc2, cex = 0.6, hang = -1, main = "Dendrogram of species")

#clust.1 <- cutree(hc2, k = is.count)

#I have made the number of clusters = to the number of species, curious to see if clustering groups them together as such
#species.clusters = as.data.table(cbind(ic.all.df,clust.1),keep.rownames = T)
#species.clusters = cbind(species.clusters,species)
#(species.clusters[order(rn,clust.1)])

#(species.clusters[,unique(species), by = clust.1])

#(species.clusters[,length(unique(species)), by = clust.1]) #This might be useful for grouping

###Now compare the average per species response to look for grouping

#First look at it for all years and actions
ic.avg.df = cover.climate[Native.Status=="I",.(SpeciesID,change_f.tran,change_cov.2.T)]
ic.avg.df = na.omit(ic.avg.df)
ic.avg.df[,f.change:=mean(change_f.tran), by = SpeciesID]
ic.avg.df[,cov.change:=mean(change_cov.2.T), by = SpeciesID]
ic.avg.df[,change_f.tran:=NULL]
ic.avg.df[,change_cov.2.T:=NULL]
ic.avg.df = as.data.frame(unique(ic.avg.df))

species = as.character(ic.avg.df$SpeciesID)
ic.avg.df$SpeciesID = as.character(ic.avg.df$SpeciesID)
rownames(ic.avg.df) = ic.avg.df$SpeciesID
ic.avg.df$SpeciesID <- NULL
ic.avg.df = scale(ic.avg.df)

# vector of methods to compare
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")
 
# function to compute coefficient
ac <- function(x) {
  agnes(ic.avg.df, method = x)$ac
}
#map_dbl(m, ac)      

#Ward’s method gets us the highest agglomerative coefficient. Let us look at its dendogram.
hc.avg.1 <- agnes(ic.avg.df, method = "ward")
pltree(hc.avg.1, cex = 0.6, hang = -1, main = "Dendrogram of species")

#create differing numbers of cluster groups
clust.avg.2 <- cutree(hc.avg.1, k = 2)
clust.avg.3 <- cutree(hc.avg.1, k = 3)
clust.avg.4 <- cutree(hc.avg.1, k = 4)
clust.avg.5 <- cutree(hc.avg.1, k = 5)
clust.avg.6 <- cutree(hc.avg.1, k = 6)


#Now map on species attributes...are there clear patterns to how the species are clustered?
z=unique(i.species.dt[,.(SpeciesID,Photopath,Legume,Duration, Type, Range, Distribution)])
z$SpeciesID = as.character(z$SpeciesID)

ic.avg.clust = ic.avg.df
ic.avg.clust = cbind(ic.avg.clust,SpeciesID =row.names(ic.avg.clust))

ic.avg.clust = merge(ic.avg.clust,z, by = c("SpeciesID"))
ic.avg.clust$f.change = as.numeric(as.character(ic.avg.clust$f.change))
ic.avg.clust$cov.change = as.numeric(as.character(ic.avg.clust$cov.change))
  
#Append cluster designations 
species.clusters = as.data.table(cbind(ic.avg.df,clust.avg.2),keep.rownames = T)
species.clusters = cbind(species.clusters,clust.avg.3)
species.clusters = cbind(species.clusters,clust.avg.4)
species.clusters = cbind(species.clusters,clust.avg.5)
species.clusters = cbind(species.clusters,clust.avg.6)
setnames(species.clusters,"rn","SpeciesID")


species.clusters = merge(species.clusters,z, by = c("SpeciesID"))

#Make some tables for quick visualization

#2 clusters
table(species.clusters$clust.avg.2,species.clusters$Photopath)
table(species.clusters$Duration,species.clusters$clust.avg.2)
table(species.clusters$Type,species.clusters$clust.avg.2)
table(species.clusters$Legume,species.clusters$clust.avg.2)

#3 clusters
table(species.clusters$Photopath,species.clusters$clust.avg.3)
table(species.clusters$Duration,species.clusters$clust.avg.3)
table(species.clusters$Type,species.clusters$clust.avg.3)
table(species.clusters$Legume,species.clusters$clust.avg.3)

######## CLusters by Species AND Year

#First look at it for all years and actions
ic.avg.df.2 = cover.climate[Native.Status=="I",.(SpeciesID,Year,change_f.tran,change_cov.2.T)]
ic.avg.df.2 = na.omit(ic.avg.df.2)
ic.avg.df.2[,f.change:=mean(change_f.tran), by = .(SpeciesID, Year)]
ic.avg.df.2[,cov.change:=mean(change_cov.2.T), by = .(SpeciesID, Year)]
ic.avg.df.2[,change_f.tran:=NULL]
ic.avg.df.2[,change_cov.2.T:=NULL]
ic.avg.df.2 = as.data.frame(unique(ic.avg.df.2))

SpeciesID = as.character(ic.avg.df.2$SpeciesID)
Year = as.character(ic.avg.df.2$Year)
ic.avg.df.2$SpeciesID = as.character(ic.avg.df.2$SpeciesID)
rownames(ic.avg.df.2) = paste(ic.avg.df.2$SpeciesID,ic.avg.df.2$Year, sep ="-")
ic.avg.df.2$SpeciesID <- NULL
ic.avg.df.2$Year <- NULL

a.1 = length(Year[Year=="2011"])
a.2 = length(Year[Year=="2012"])+a.1
a.3 = length(Year[Year=="2013"])+a.2
a.4 = length(Year[Year=="2014"])+a.3
a.5 = length(Year[Year=="2015"])+a.4
a.6 = length(Year[Year=="2016"])+a.5
a.7 = length(Year[Year=="2017"])+a.6
a.8 = length(Year[Year=="2018"])+a.7

yr.count = c(0,a.1,a.2,a.3,a.4,a.5,a.6,a.7,a.8)

ic.11 = scale(ic.avg.df.2[1:yr.count[2],])
ic.12 = scale(ic.avg.df.2[(1+yr.count[2]):yr.count[3],])
ic.13 = scale(ic.avg.df.2[(1+yr.count[3]):yr.count[4],])
ic.14 = scale(ic.avg.df.2[(1+yr.count[4]):yr.count[5],])
ic.15 = scale(ic.avg.df.2[(1+yr.count[5]):yr.count[6],])
ic.16 = scale(ic.avg.df.2[(1+yr.count[6]):yr.count[7],])
ic.17 = scale(ic.avg.df.2[(1+yr.count[7]):yr.count[8],])
ic.18 = scale(ic.avg.df.2[(1+yr.count[8]):yr.count[9],])

ic.avg.df.2 = as.data.frame(rbind(ic.11,ic.12,ic.13,ic.14,ic.15,ic.16,ic.17,ic.18))

ic.avg.df.2 = cbind(ic.avg.df.2,Year,SpeciesID)

#aa = c(row.names(ic.avg.df.2))
#aa = substr(aa,1,stop = nchar(aa)-5)
#row.names(ic.avg.df.2) = aa

# vector of methods to compare
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")
 
# function to compute coefficient
ac <- function(x) {
  for (i in years){
  agnes(as.data.frame(as.data.table(ic.avg.df.2)[Year==i,.(f.change,cov.change)]), method = x)$ac
  }
}
#map_dbl(m, ac)      

#Ward’s method gets us the highest agglomerative coefficient. Let us look at its dendogram.
hc.yr.1=list()
species.clusters = c()
Years = as.character(unique(ic.avg.df.2$Year))
for (i in 1:length(Years)){
  hc.yr.1[[i]]=agnes(as.data.frame(as.data.table(ic.avg.df.2)[Year==Years[i],.(f.change,cov.change)]), method = "ward")
  species.clusters = c(species.clusters,as.data.table(ic.avg.df.2)[Year==Years[i],SpeciesID])
}

pltree(hc.yr.1[[1]], cex = 0.6, hang = -1, main = "Dendrogram of species 2011")
#Can create others for other years


#create differing numbers of cluster groups
clust.yr.2 = c()
clust.yr.3 = c()
clust.yr.4 = c()
clust.yr.5 = c()
clust.yr.6 = c()

year.clust = c()

for (i in 1:length(Years)){
clust.yr.2 <- c(clust.yr.2,cutree(hc.yr.1[[i]], k = 2))
clust.yr.3 <- c(clust.yr.3,cutree(hc.yr.1[[i]], k = 3))
clust.yr.4 <- c(clust.yr.4,cutree(hc.yr.1[[i]], k = 4))
clust.yr.5 <- c(clust.yr.5,cutree(hc.yr.1[[i]], k = 5))
clust.yr.6 <- c(clust.yr.6,cutree(hc.yr.1[[i]], k = 6))
year.clust = c(year.clust, rep(x = i, times = length(hc.yr.1[[i]]$order)))
}

#Now map on species attributes...are there clear patterns to how the species are clustered?
z=unique(i.species.dt[,.(SpeciesID,Photopath,Legume,Duration,Type, Range, Distribution)])


ic.yr.clust = ic.avg.df.2
#ic.yr.clust = cbind(ic.yr.clust,SpeciesID =row.names(ic.avg.clust))

ic.yr.clust = merge(ic.yr.clust,z, by = c("SpeciesID"))
ic.yr.clust$f.change = as.numeric(as.character(ic.yr.clust$f.change))
ic.yr.clust$cov.change = as.numeric(as.character(ic.yr.clust$cov.change))

#years = as.numeric(as.character((years)))

#Combine years for all cluster combinations to get an average sense
ic.yr.dt = as.data.table(ic.avg.df.2)
ic.yr.dt$clust.2 = clust.yr.2
ic.yr.dt$clust.3 = clust.yr.3
ic.yr.dt$clust.4 = clust.yr.4
ic.yr.dt$clust.5 = clust.yr.5
ic.yr.dt$clust.6 = clust.yr.6

ic.yr.dt$SpeciesID = as.numeric(as.character(ic.yr.dt$SpeciesID))

ic.yr.dt = merge(ic.yr.dt,z, by = "SpeciesID")

ic.yr.dt[,length(clust.2),by = Type]

#Save all the objects to load into Visualization Rmd File
setwd("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis")
save(list = c("clust.yr.2","clust.yr.3","clust.yr.4","clust.yr.5","clust.yr.6", "ic.yr.dt", "ic.avg.df.2",'ic.avg.df','ic.avg.clust','ic.avg.df'), file = "cluster.rda")

```


#Models
Create comprehensive FE models which incorporate multiple climate indices into single model.

##Growing Season Model

###Fixed Effects

####Transect means and groups
```{r GSL-tran-fe}
######Model Without Groups

#Create master modeling list to easily control the models

grow.response = c('if.tran',"rel.cov.i.2","nf.tran","rel.cov.n.2"
                  ,'indf.i.tran', 'rel.cov.ind.i.2', 'indf.n.tran', 'rel.cov.ind.n.2'
                  ,'indf.i1.tran', 'rel.cov.ind.i1.2', 'indf.n1.tran', 'rel.cov.ind.n1.2')

grow.index = c('gsl + wsdi.lag + csdi.lag + sdii.lag + cdd.lag + cwd.lag + rx5.sum + rx5.sum.lag + rx5.sp + rx5.sp.lag'
               ) #Each entry represents index terms to consider simultaneously

grow.variant = c(" + Action + nr_tran.lag"
                 ," + Action + sr_tran.lag"
                 ," + Action + nr_tran.lag + ObsCode"
                 ," + Action + sr_tran.lag + ObsCode"
                 ) #Each entry represents the time varying terms to consider

grow.interact = c(" + Action:gsl"
                  , ' + Action:gsl + Action:cdd.lag + Action:sdii.lag'
                  #" + Action:gsl + Action:sdii",
                  #" + Action:gsl + Action:sdii + Action:gsl.lag + Action:sdii.lag"
                  )
    
#The fellowing creates a data frame of terms to build model from within loop
grow.model.terms = as.data.table(expand.grid(grow.response=grow.response,grow.index=grow.index,grow.variant=grow.variant,grow.interact=grow.interact, stringsAsFactors = FALSE))

#Now create a loop to run a felm model for each model term combination and store the model within a list and the model summary within a list...RERUN terms above first
grow.models = list()
grow.m.summaries = list()
grow.m.coeffs = list()

#Modeling loop
for ( i in 1:length(grow.model.terms$grow.response)){
  modelformula <- paste(noquote(grow.model.terms[i,grow.response]), "~", noquote(grow.model.terms[i,grow.index]),noquote(grow.model.terms[i,grow.variant]),
                        noquote(grow.model.terms[i,grow.interact]), "| TransectID",sep = " ")
  grow.models[[modelformula]] = felm(as.formula(modelformula), data = tran.dt, exactDOF='rM')
  grow.m.summaries[[modelformula]] = summary(grow.models[[i]],robust = TRUE, cluster = TRUE)
  grow.m.coeffs[[modelformula]] = broom::tidy(grow.models[[i]], conf.int = T)
}


######Model WITH Groups

#Modify group names to account for if indlvl analysis is removed 
group.names.grow = group.names

Nth.delete<-function(dataframe, n)dataframe[-(seq(n,to=nrow(dataframe),by=n)),]

group.names.grow = Nth.delete(group.names.grow,3)

categories.grp = c("Native.Status", "Ind.class"#,"Indlvl"
                   )

status = c("I", "N")

resp.cnt = c("freq", "cover")

grow.response.grp = as.character(expression(f.T.dur,rel.cov.2.dur, f.ind.dur, rel.cov.2.ind.dur#,f.indlvl.dur, rel.cov.2.indlvl.dur
                                            ,f.T.type,rel.cov.2.type, f.ind.type, rel.cov.2.ind.type#,f.indlvl.type, rel.cov.2.indlvl.type
                                            #Photopath aren't really interesting yet, leave out for now
                                            #,f.T.photo, rel.cov.2.photo, f.ind.photo, rel.cov.2.ind.photo,f.indlvl.photo, rel.photo.2.indlvl.photo,
                                            ,f.T.range,  rel.cov.2.range, f.ind.range, rel.cov.2.ind.range#,f.indlvl.range, rel.cov.2.indlvl.range
                                            ,f.T.dist, rel.cov.2.dist,f.ind.dist, rel.cov.2.ind.dist#, f.indlvl.dist, rel.cov.2.indlvl.dist
                                            ,f.T.season,rel.cov.2.season, f.ind.season, rel.cov.2.ind.season #,f.indlvl.season, rel.cov.2.indlvl.season
                                            ))

groups = unique(group.names.grow$V7)
#Remove photo and legume for now
groups =groups[!(groups=="Photopath" | groups=="Legume")]

dt.grps = as.data.frame(data.table(invasive = rep(group.names.grow[!(V7=="Photopath" | V7=="Legume"),V3],each =length(resp.cnt)), native = rep(group.names.grow[!(V7=="Photopath" | V7=="Legume"),V5], each = length(resp.cnt))))

grow.index.grp = grow.index  #Each entry represents index terms to consider simultaneously

grow.variant.grp = grow.variant #Each entry represents the time varying terms to consider

grow.interact.grp = grow.interact


#The fellowing creates a data frame of terms to build model from within loop
prelim.terms.grp = as.data.table(expand.grid(grow.index.grp=grow.index.grp,grow.variant.grp=grow.variant.grp,grow.interact.grp=grow.interact.grp, stringsAsFactors = FALSE))

#write a loop to correctly expand matrix with groups and associated data tables
grow.setup = as.data.table(data.frame(grow.response.grp = rep(grow.response.grp, each = length(status)), status = rep(status, times = length(grow.response.grp)), groups = rep(groups, 
                        each = (length(status) * length(resp.cnt) * length(categories.grp))), 
                        categories.grp = rep(categories.grp, each = length(status)*length(resp.cnt), times = length(groups))))

grp.datatables = c()
for (i in 1:(length(grow.setup$grow.response.grp)/length(status))) {
  for (k in 1:length(status)){
    grp.datatables[k + ((i-1)*length(status))] = dt.grps[i,k]  
  }
}

grow.setup = as.data.table(data.frame(grow.setup, dt.grps = grp.datatables))


grow.model.terms.grp = data.frame()
zzz=data.frame()
for (k in 1:length(grow.setup$grow.response.grp)){
  for(r in 1:length(prelim.terms.grp$grow.index.grp)){
    z = data.frame(expand.grid(grow.response.grp = grow.setup$grow.response.grp[k],groups = grow.setup$groups[k],dt.grps = grow.setup$dt.grps[k],
                               status = grow.setup$status[k], categories.grp = grow.setup$categories.grp[k],
                               grow.index.grp=prelim.terms.grp$grow.index.grp[r], grow.variant.grp=prelim.terms.grp$grow.variant.grp[r],
                               grow.interact.grp=prelim.terms.grp$grow.interact.grp[r], stringsAsFactors = F))
    zzz = rbind(zzz,z)
    }
  grow.model.terms.grp = rbind(grow.model.terms.grp,zzz)
  zzz=data.frame()
}

grow.model.terms.grp = as.data.table(grow.model.terms.grp)
#I need to reorder this so modeling and graphing is easier
grow.model.terms.grp[,sorting:=paste(grow.interact.grp,grow.variant.grp,grow.index.grp)]
setorder(grow.model.terms.grp,sorting,groups,categories.grp,grow.response.grp)

#Modeling loop
grow.m.grp = list()
grow.grp.summaries = list()
grow.grp.coeffs = list()

for ( i in 1:length(grow.model.terms.grp$grow.response.grp)){
  modelformula <- paste(noquote(grow.model.terms.grp[i,grow.response.grp]), "~", noquote(grow.model.terms.grp[i,grow.index.grp]),noquote(grow.model.terms.grp[i,grow.variant.grp]),
                  noquote(grow.model.terms.grp[i,grow.interact.grp]), '+', noquote(grow.model.terms.grp[i,groups]), "| TransectID",sep = " ")
  
  grow.m.grp[[paste(grow.model.terms.grp[i,status], " - ", modelformula)]] = felm(as.formula(modelformula), 
              data = group.list[[as.character(grow.model.terms.grp[i,dt.grps])]] , exactDOF='rM')
  
  grow.grp.summaries[[paste(grow.model.terms.grp[i,status], " - ", modelformula)]] = summary(grow.m.grp[[i]],robust = TRUE, cluster = TRUE)
  
  grow.grp.coeffs[[paste(grow.model.terms.grp[i,status], " - ", modelformula)]] = broom::tidy(grow.m.grp[[i]], conf.int = T)
}

#Save
setwd("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis")
save(list = c('grow.models', 'grow.m.summaries', 'grow.m.coeffs','grow.m.grp','grow.grp.summaries','grow.grp.coeffs',"grow.model.terms", 'grow.model.terms.grp', 'grow.response','groups', 'grow.response.grp','categories.grp', 'resp.cnt', 'status'), 
     file = "model_GSL_FE_tran.rda")

```

####Species Level
Run the same models as at the Transect means level only now subset each dataset by particular species of interest. No need for group models hurray!
```{r GSL-spec-FE }

grow.response.spec = c('Freq.T',"rel.cov.T.2","DI.T.2")

grow.index.spec = c('gsl + wsdi.lag + csdi.lag + sdii.lag + cdd.lag + cwd.lag + rx5.sum + rx5.sum.lag + rx5.sp + rx5.sp.lag'
                    ) #Each entry represents index terms to consider simultaneously


grow.variant.spec = c(" + Action + nr_tran.lag"
                 ," + Action + sr_tran.lag"
                 ," + Action + nr_tran.lag + ObsCode"
                 ," + Action + sr_tran.lag + ObsCode"
                 ) #Each entry represents the time varying terms to consider

grow.interact.spec = c(" + Action:gsl"
                  , ' + Action:gsl +  Action:cdd.lag + Action:sdii.lag'
                  #," + Action:gsl + Action:sdii"
                  #," + Action:gsl + Action:sdii + Action:gsl.lag + Action:sdii.lag"
                  )

imp.spec = imp.spec

#The fellowing creates a data frame of terms to build model from within loop....HUGH confirm no need to sort
grow.spec.terms = as.data.table(expand.grid(grow.response.spec=grow.response.spec,grow.index.spec=grow.index.spec,grow.variant.spec=grow.variant.spec,grow.interact.spec=grow.interact.spec, imp.spec = imp.spec, stringsAsFactors = FALSE))


grow.models.spec = list()
grow.spec.summaries = list()
grow.spec.coeffs = list()

#Modeling loop...HUGH still getting rank deficient error even though there is no Obs.Code
for ( i in 1:length(grow.spec.terms$grow.response.spec)){
  modelformula <- paste(noquote(grow.spec.terms[i,grow.response.spec]), "~", noquote(grow.spec.terms[i,grow.index.spec]),noquote(grow.spec.terms[i,grow.variant.spec]),
                        noquote(grow.spec.terms[i,grow.interact.spec]), "| TransectID",sep = " ")
  
  grow.models.spec[[paste(grow.spec.terms[i,imp.spec], " - ", modelformula)]] = felm(as.formula(modelformula), 
                        data = cover.climate[SpeciesID==grow.spec.terms[i,imp.spec],], exactDOF='rM')
  
  grow.spec.summaries[[paste(grow.spec.terms[i,imp.spec], " - ", modelformula)]] = summary(grow.models.spec[[i]],robust = TRUE, cluster = TRUE)
  
  grow.spec.coeffs[[paste(grow.spec.terms[i,imp.spec], " - ", modelformula)]] = broom::tidy(grow.models.spec[[i]], conf.int = T)
}

#Save
setwd("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis")
save(list = c('grow.models.spec', 'grow.spec.summaries', 'grow.spec.coeffs', 'grow.spec.terms', 'grow.response.spec', 'imp.spec'), 
     file = "model_GSL_FE_spec.rda")

``` 

###Lagged

####Transect means and groups
```{r GSL-tran-le} 
#The lagged models should be the same as above with the addition of a lagged response variable and the removal of the fixed effect. Use the same terms as above to streamline model design and avoid errors. 

#Call the terms to confirm they are correct

######Model Without Groups

#Create master modeling list to easily control the models

#call terms
print(grow.response)
print(grow.index)
print(grow.interact)
print(grow.variant)

#Create new lagged terms
grow.lag = paste(grow.response,".lag", sep = "")


#The fellowing creates a data frame of terms to build model from within loop
grow.lag.terms = as.data.table(expand.grid(grow.lag=grow.lag,grow.index=grow.index,grow.variant=grow.variant,grow.interact=grow.interact, stringsAsFactors = FALSE))

#Now create a loop to run a felm model for each model term combination and store the model within a list and the model summary within a list...RERUN terms above first
grow.lagged = list()
grow.lagged.summaries = list()
grow.lagged.coeffs = list()

#Modeling loop
for ( i in 1:length(grow.lag.terms$grow.lag)){
  modelformula <- paste(noquote(grow.lag.terms[i,grow.lag]), "~", noquote(grow.lag.terms[i,grow.index]),noquote(grow.lag.terms[i,grow.variant]),
                        noquote(grow.lag.terms[i,grow.interact]),sep = " ")
  grow.lagged[[modelformula]] = felm(as.formula(modelformula), data = tran.dt.lag, exactDOF='rM')
  grow.lagged.summaries[[modelformula]] = summary(grow.lagged[[i]], robust = TRUE, cluster = TRUE)
  grow.lagged.coeffs[[modelformula]] = broom::tidy(grow.lagged[[i]], conf.int = T)
}


######Model WITH Groups
 
#call terms
print(grow.response.grp)
print(groups)
print(dt.grps)
print(grow.index.grp) 
print(grow.variant.grp) 
print(grow.interact.grp) 
print(categories.grp) 
print(status)
print(resp.cnt)

#Create new lagged terms
grow.lag.grp = paste(grow.response.grp,".lag", sep = "")
dt.lag.grps = dt.grps
dt.lag.grps$invasive = paste(dt.grps$invasive,".lag", sep = "")
dt.lag.grps$native = paste(dt.grps$native,".lag", sep = "")


#The fellowing creates a data frame of terms to build model from within loop
prelim.terms.grp.lag = as.data.table(expand.grid(grow.index.grp=grow.index.grp,grow.variant.grp=grow.variant.grp,grow.interact.grp=grow.interact.grp, stringsAsFactors = FALSE))

#write a loop to correctly expand matrix with groups and associated data tables
grow.setup.lag = as.data.table(data.frame(grow.lag.grp = rep(grow.lag.grp, each = length(status)), status = rep(status, times = length(grow.lag.grp)), groups = rep(groups, 
                        each = (length(groups) * length(categories.grp))), categories.grp = rep(categories.grp, each = length(status)*length(resp.cnt), times = length(groups))))

grp.datatables.lag = c()
for (i in 1:(length(grow.setup.lag$grow.lag.grp)/length(status))) {
  for (k in 1:length(status)){
    grp.datatables.lag[k + ((i-1)*length(status))] = dt.lag.grps[i,k]  
  }
}

grow.setup.lag = as.data.table(data.frame(grow.setup.lag, dt.lag.grps = grp.datatables.lag))


grow.lag.terms.grp = data.frame()
zzz=data.frame()
for (k in 1:length(grow.setup.lag$grow.lag.grp)){
  for(r in 1:length(prelim.terms.grp.lag$grow.index.grp)){
    z = data.frame(expand.grid(grow.lag.grp = grow.setup.lag$grow.lag.grp[k],groups = grow.setup.lag$groups[k],dt.lag.grps = grow.setup.lag$dt.lag.grps[k],
                               status = grow.setup.lag$status[k], categories.grp = grow.setup.lag$categories.grp[k],
                               grow.index.grp=prelim.terms.grp.lag$grow.index.grp[r], grow.variant.grp=prelim.terms.grp.lag$grow.variant.grp[r],
                               grow.interact.grp=prelim.terms.grp.lag$grow.interact.grp[r], stringsAsFactors = F))
    zzz = rbind(zzz,z)
    }
  grow.lag.terms.grp = rbind(grow.lag.terms.grp,zzz)
  zzz=data.frame()
}

grow.lag.terms.grp = as.data.table(grow.lag.terms.grp)
#I need to reorder this so modeling and graphing is easier
grow.lag.terms.grp[,sorting:=paste(grow.interact.grp,grow.variant.grp,grow.index.grp)]
setorder(grow.lag.terms.grp,sorting,groups,categories.grp,grow.lag.grp)


#Modeling loop

grow.lagged.grp = list()
grow.lagged.summaries.grp = list()
grow.lagged.coeffs.grp = list()

for ( i in 1:length(grow.lag.terms.grp$grow.lag.grp)){
  modelformula <- paste(noquote(grow.lag.terms.grp[i,grow.lag.grp]), "~", noquote(grow.lag.terms.grp[i,grow.index.grp]),noquote(grow.lag.terms.grp[i,grow.variant.grp]),
                        noquote(grow.lag.terms.grp[i,grow.interact.grp]), '+', noquote(grow.lag.terms.grp[i,groups]),sep = " ")
  grow.lagged.grp[[modelformula]] = felm(as.formula(modelformula), data = group.list[[as.character(grow.lag.terms.grp[i,dt.lag.grps])]] , exactDOF='rM')
  grow.lagged.summaries.grp[[modelformula]] = summary(grow.lagged.grp[[i]],robust = TRUE, cluster = TRUE)
  grow.lagged.coeffs.grp[[modelformula]] = broom::tidy(grow.lagged.grp[[i]], conf.int = T)
}

setwd("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis")
save(list = c('grow.lagged', 'grow.lagged.summaries', 'grow.lagged.coeffs','grow.lagged.grp','grow.lagged.summaries.grp','grow.lagged.coeffs.grp'),
     file = "model_GSL_LE_tran.rda")

```

####Species Level
Run the same models as at the Transect means level only now subset each dataset by particular species of interest. No need for group models hurray!
```{r GSL-spec-LE }

grow.response.spec.lag = paste(grow.response.spec, ".lag", sep = "") 

#grow.index.spec 
#grow.variant.spec 
#grow.interact.spec 
#imp.spec = imp.spec

#The fellowing creates a data frame of terms to build model from within loop....HUGH confirm no need to sort
grow.spec.terms.lag = as.data.table(expand.grid(grow.response.spec.lag=grow.response.spec.lag,grow.index.spec=grow.index.spec,grow.variant.spec=grow.variant.spec,grow.interact.spec=grow.interact.spec, imp.spec = imp.spec, stringsAsFactors = FALSE))


grow.models.spec.lag = list()
grow.spec.summaries.lag = list()
grow.spec.coeffs.lag = list()

#Modeling loop...HUGH still getting rank deficient error even though there is no Obs.Code
for ( i in 1:length(grow.spec.terms.lag$grow.response.spec.lag)){
  modelformula <- paste(noquote(grow.spec.terms.lag[i,grow.response.spec.lag]), "~", noquote(grow.spec.terms.lag[i,grow.index.spec]),noquote(grow.spec.terms.lag[i,grow.variant.spec]),
                        noquote(grow.spec.terms.lag[i,grow.interact.spec]),sep = " ")
  grow.models.spec.lag[[modelformula]] = felm(as.formula(modelformula), data = cover.climate[SpeciesID==grow.spec.terms.lag[i,imp.spec],], exactDOF='rM')
  grow.spec.summaries.lag[[modelformula]] = summary(grow.models.spec.lag[[i]],robust = TRUE, cluster = TRUE)
  grow.spec.coeffs.lag[[modelformula]] = broom::tidy(grow.models.spec.lag[[i]], conf.int = T)
}

#Save
setwd("/Volumes/GoogleDrive/My Drive/Thesis/Prairies/Data And Analysis/Prairie Analysis/Prairie-Analysis")
save(list = c('grow.models.spec.lag', 'grow.spec.summaries.lag', 'grow.spec.coeffs.lag', 'grow.spec.terms.lag', 'grow.response.spec.lag', 'imp.spec'), 
     file = "model_GSL_LE_spec.rda")

``` 



##Drought Model

###Fixed Effects

####Transect means and groups
```{r indices-fe}
######Model Without Groups

#Create master modeling list to easily control the models

responses = c("ir_tran","if.tran","rel.cov.i.2","meanDI.i.tran.2")

index.coms = c("cdd + sdii + gsl + cwd + wsdi + prcpt.lag",
                 "cdd.lag + sdii.lag + gsl.lag + cwd.lag + wsdi.lag + prcpt.lag") #Each entry represents index terms to consider simultaneously

variant.effects = c("+ nr_tran.lag + VOR.lag + Action",
                      "+ Action") #Each entry represents the time varying terms to consider
interactions = c(" + Action:gsl + Action:sdii",
                   "+ Action:gsl.lag + Action:sdii.lag")
    
#The fellowing creates a data frame of terms to build model from within loop
model.terms = as.data.table(expand.grid(responses=responses,index.coms=index.coms,variant.effects=variant.effects,interactions=interactions, stringsAsFactors = FALSE))

#Now create a loop to run a felm model for each model term combination and store the model within a list and the model summary within a list...RERUN terms above first
drought.models = list()
drought.m.summaries = list()
drought.m.coeffs = list()

#Modeling loop
for ( i in 1:length(model.terms$responses)){
  modelformula <- paste(noquote(model.terms[i,responses]), "~", noquote(model.terms[i,index.coms]),noquote(model.terms[i,variant.effects]),
                        noquote(model.terms[i,interactions]), "| TransectID",sep = " ")
  drought.models[[i]] = felm(as.formula(modelformula), data = tran.dt, exactDOF='rM')
  drought.m.summaries[[i]] = summary(drought.models[[i]])
  drought.m.coeffs[[i]] = broom::tidy(drought.models[[i]], conf.int = T)
}


#Plot effects: all response variable per model type
coeff.dt = data.frame()
for (k in 1:(length(model.terms$responses)/length(responses))) {
  coeff.dt = data.frame()
    for (i in 1:length(responses)) {
    coeff.dt = rbind(coeff.dt,drought.m.coeffs[[i+(length(responses)*(k-1))]])
    }
  coeff.dt$response = rep(responses,each = length(coeff.dt$term)/length(responses))
  
  plot = ggplot(data = coeff.dt ,aes(x=term, y=estimate, ymin=conf.low, ymax=conf.high)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~response)+
  labs(Title = "Effects on Invasive Species") +
  geom_hline(yintercept = 0, col = "orange") +
  ylim(-0.3, 0.3 ) +
  #labs(title = "Effects on Invasive Richness") +
  theme(axis.title.x = element_blank(),axis.title.y = element_blank())
  print(plot)
}





######Model WITH Groups
responses = as.character(expression(r.T.dur , f.T.dur,rel.cov.2.dur, meanDI.2.dur,
                                    r.T.type,f.T.type,rel.cov.2.type,meanDI.2.type,
                                    r.T.leg, f.T.leg,rel.cov.2.leg, meanDI.2.leg, 
                                    #not enough data for photo to use it 
                                    #r.T.photo,f.T.photo, rel.cov.2.photo, meanDI.2.photo, 
                                    r.T.range, f.T.range,  rel.cov.2.range, meanDI.2.range,
                                    r.T.dist,f.T.dist, rel.cov.2.dist, meanDI.2.dist))
groups = group.names$V7
#have to remove photo for now
groups =groups[!groups=="Photopath"]

dt.grps = group.names$V3
#have to remove photo for now
dt.grps = dt.grps[!dt.grps=="i.photo.dt"]

index.coms = c("cdd + sdii + gsl + cwd + wsdi + prcpt.lag",
                 "cdd.lag + sdii.lag + gsl.lag + cwd.lag + wsdi.lag + prcpt.lag") #Each entry represents index terms to consider simultaneously

variant.effects = c("+ nr_tran.lag + VOR.lag + Action",
                      "+ Action") #Each entry represents the time varying terms to consider
interactions = c(" + Action:gsl + Action:sdii",
                   "+ Action:gsl.lag + Action:sdii.lag")


#The fellowing creates a data frame of terms to build model from within loop
prelim.terms.grp = as.data.table(expand.grid(index.coms=index.coms,variant.effects=variant.effects,interactions=interactions, stringsAsFactors = FALSE))

#write a loop to correctly expand matrix with groups and associated data tables
model.terms.grp=data.frame()
zz=data.frame()
for (i in 1:length(groups)) {
  z = data.frame(expand.grid(responses = responses[1+((length(responses)/length(groups)*(i-1))):((length(responses)/length(groups)*(i))-1)],groups=groups[i],dt.grps = dt.grps[i],stringsAsFactors = F))
  zz =rbind(zz,z) 
}

zzz=data.frame()
for (k in 1:length(zz$groups)){
  for(r in 1:length(prelim.terms.grp$index.coms)){
    z = data.frame(expand.grid(responses = zz$responses[k],groups = zz$groups[k],dt.grps = zz$dt.grps[k],
                               index.coms=prelim.terms.grp$index.coms[r], variant.effects=prelim.terms.grp$variant.effects[r], interactions=prelim.terms.grp$interactions[r], stringsAsFactors = F))
    zzz = rbind(zzz,z)
    }
  model.terms.grp = rbind(model.terms.grp,zzz)
  zzz=data.frame()
}

model.terms.grp = as.data.table(model.terms.grp)
#I need to reorder this so modeling and graphing is easier
model.terms.grp[,sorting:=paste(interactions,variant.effects,index.coms)]
setorder(model.terms.grp,sorting,groups,responses)

#Modeling loop

drought.m.grp = list()
drought.grp.summaries = list()
drought.grp.coeffs = list()

for ( i in 1:length(model.terms.grp$responses)){
  modelformula <- paste(noquote(model.terms.grp[i,responses]), "~", noquote(model.terms.grp[i,index.coms]),noquote(model.terms.grp[i,variant.effects]),
                        noquote(model.terms.grp[i,interactions]), '+', noquote(model.terms.grp[i,groups]), "| TransectID",sep = " ")
  drought.m.grp[[i]] = felm(as.formula(modelformula), data = group.list[[model.terms.grp[i,dt.grps]]] , exactDOF='rM')
  drought.grp.summaries[[i]] = summary(drought.m.grp[[i]])
  drought.grp.coeffs[[i]] = broom::tidy(drought.m.grp[[i]], conf.int = T)
}


#Plot effects: all response variable per model type
coeff.grp.dt = data.frame()
coef.resp = c()
coef.grp = c()
for (k in 1:(length(model.terms.grp$responses)/(length(responses)))) {
  for (i in 1:length(groups)){
    coeff.grp.dt=data.frame()
    coef.resp = c()
    coef.grp = c()
    for (r in 1:(length(responses)/length(groups))){
      coeff.grp.dt = rbind(coeff.grp.dt,
                       drought.grp.coeffs[[ r + (length(responses)/length(groups)*(i-1)) + (length(groups)*(length(responses)/length(groups)*(k-1)))]])
     
       coef.resp = c(coef.resp, 
                    rep(responses[r+(length(responses)/length(groups)*(i-1))] ,each = length(drought.grp.coeffs[[r + (length(responses)/length(groups)*(i-1)) + (length(groups)*(length(responses)/length(groups)*(k-1)))]]$term)))
      
       coef.grp = c(coef.grp, 
                    rep(responses[r+(length(responses)/length(groups)*(i-1))] ,each = length(drought.grp.coeffs[[r + (length(responses)/length(groups)*(i-1)) + (length(groups)*(length(responses)/length(groups)*(k-1)))]]$term)))
      
       }
      
    coeff.grp.dt = cbind(coeff.grp.dt,coef.grp,coef.resp)
  
  #Now plot using this coefficient table  
  plot = ggplot(data = coeff.grp.dt ,aes(x=term, y=estimate, ymin=conf.low, ymax=conf.high)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~coef.resp)+
  labs(Title = "Effects on Invasive Species") +
  geom_hline(yintercept = 0, col = "orange") +
  ylim(-0.3, 0.3 ) +
  #labs(title = "Effects on Invasive Richness") +
  theme(axis.title.x = element_blank(),axis.title.y = element_blank())
  print(plot)
  }
}
  
```
  
####Species Level

###Lagged effects

####Transect means and groups

```{r indices-le}

#IR
ind.ir.1.lag = felm(ir_tran ~ ir_tran.lag + nr_tran + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = tran.dt.lag, exactDOF='rM')

summary(ind.ir.1.lag,robust = TRUE, cluster = TRUE)

##Hugh run each one with obscode as a random effect

#IF
ind.if.1.lag = felm(if.tran ~ if.tran.lag + nr_tran + nr_tran.lag + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii, 
                    data = tran.dt.lag, exactDOF='rM')

summary(ind.if.1.lag,robust = TRUE, cluster = TRUE)

#Relative Cover
ind.irc.1.lag = felm(ihs(rel.cov.i.2) ~ rel.cov.i.2.lag + nr_tran + nr_tran.lag + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = tran.dt.lag, exactDOF='rM')

summary(ind.irc.1.lag,robust = TRUE, cluster = TRUE)

#Dominance 
ind.iDI.1.lag = felm(meanDI.i.tran.2 ~ meanDI.i.tran.2.lag  + nr_tran.lag  + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = tran.dt.lag,  exactDOF='rM')

summary(ind.iDI.1.lag,robust = TRUE, cluster = TRUE)

```

####Species Level




##Species
###Fixed effects
```{r indices-fe-sp}
#IF
ind.iSf.1 = felm(Freq.T ~ nr_tran + nr_tran.lag + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = i.species.dt[])

summary(ind.iSf.1)

#Relative Cover
ind.iSrc.1 = felm(rel.cov.T.2 ~ nr_tran + nr_tran.lag + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = i.species.dt, exactDOF='rM')

summary(ind.iSrc.1,robust = TRUE, cluster = TRUE)

#Dominance 
ind.iSDI.1 = felm(DI.T.2 ~ nr_tran + nr_tran.lag  + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = i.species.dt)

summary(ind.iSDI.1)

```

###Lagged
```{r indices-le-sp}
#IR
ind.ir.1.lag = felm(ir_tran ~ ir_tran.lag + nr_tran + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = i.species.dt.lag, exactDOF='rM')

summary(ind.ir.1.lag,robust = TRUE, cluster = TRUE)

##Hugh run each one with obscode as a random effect

#IF
ind.if.1.lag = felm(if.tran ~ if.tran.lag + nr_tran + nr_tran.lag + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii, 
                    data = i.species.dt.lag, exactDOF='rM')

summary(ind.if.1.lag,robust = TRUE, cluster = TRUE)

#Relative Cover
ind.irc.1.lag = felm(rel.cov.i.2 ~ rel.cov.i.2.lag + nr_tran + nr_tran.lag + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = i.species.dt.lag, exactDOF='rM')

summary(ind.irc.1.lag,robust = TRUE, cluster = TRUE)

#Dominance 
ind.iDI.1.lag = felm(meanDI.i.tran.2 ~ meanDI.i.tran.2.lag + nr_tran + nr_tran.lag  + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                , data = i.species.dt.lag,  exactDOF='rM')

summary(ind.iDI.1.lag,robust = TRUE, cluster = TRUE)

```
















## TXx (max temperature) 

##Transect

###Mixed effects
```{r Invasives-ME-TXX}

###Explore linear relationship between TXx and Abundance 

#IR
txx.ir.lm.1 = lm(ir_tran ~ 1 + txx, data = tran.dt)

summary(txx.ir.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.ir.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.ir.lm.1)

#F
txx.if.lm.1 = lm(if.tran ~ 1 + txx, data = tran.dt)

summary(txx.if.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.if.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.if.lm.1)

#Relative Cover
txx.rel.cov.lm.1 = lm(rel.cov.i.2 ~ 1 + txx, data = tran.dt)

summary(txx.rel.cov.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.rel.cov.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.rel.cov.lm.1)

#Mean DI
txx.DI.lm.1 = lm( meanDI.I_tran.2 ~ 1 + txx, data = tran.dt)

summary(txx.DI.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.DI.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.DI.lm.1)



###Add more independent variables to this regression

#IR
txx.ir.lm.2 = lm(ir_tran ~ Action + txx, data = tran.dt)

summary(txx.ir.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.ir.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.ir.lm.2)

#F
txx.if.lm.2 = lm(if.tran ~ Action + txx, data = tran.dt)

summary(txx.if.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.if.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.if.lm.2)

#Relative Cover
txx.rel.cov.lm.2 = lm(rel.cov.i.2 ~ Action + txx, data = tran.dt)

summary(txx.rel.cov.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.rel.cov.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.rel.cov.lm.2)

#Mean DI
txx.DI.lm.2 = lm( meanDI.I_tran ~ Action + txx, data = tran.dt)

summary(txx.DI.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.DI.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.DI.lm.2)



####Add some interaction to the model

#IR
txx.ir.lm.3 = lm(ir_tran ~ Action + txx + Action*txx, data = tran.dt)

summary(txx.ir.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.ir.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.ir.lm.3)

#F
txx.if.lm.3 = lm(if.tran ~ Action + txx + Action*txx, data = tran.dt)

summary(txx.if.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.if.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.if.lm.3)

#Relative Cover
txx.rel.cov.lm.3 = lm(rel.cov.i.2 ~ Action + txx + Action*txx, data = tran.dt)

summary(txx.rel.cov.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.rel.cov.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.rel.cov.lm.3)

#Mean DI
txx.DI.lm.3 = lm( meanDI.I_tran ~ Action + txx + Action*txx, data = tran.dt)

summary(txx.DI.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(txx.DI.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(txx.DI.lm.3)



#########################Now consider transect as a fixed effect, create a strong global model

#For discussion with Laura...data is limited by years we have climate data for an missing the 2019 data which will give us more years. That being said, there still is not a lot of variabiation in action type - see lines below. I imagine if looked at some sort of management frequency this would be less of an issue.

tran.dt[,length(unique(Year)),by=Action]

tran.dt[,length(unique(Action)),by=Year]

tran.dt[,length(unique(Action)),by=.(Year,SITE_ID)]

#Also, I have not filtered the data to only include transects with two years worth of data. This does not appear to affect the rank deficiency issue

tran.dt[,length(unique(TransectID))]
tran.dt[Delta==1,length(unique(TransectID))] #substantially fewer transects, most of this is a product of incomplete climate data and missing 2019 data

#### First with the Lme4 package

#IR
txx.ir.lmer.1 = lmer(ir_tran ~ Action*txx + txx + VOR + nr_tran + (1|SITE_ID), data = tran.dt)

summary(txx.ir.lmer.1)

#F
txx.if.lmer.1 = lmer(if.tran ~  txx + SITE_ID + VOR + nr_tran + Action*txx + (1|ObsCode), data = tran.dt)

summary(txx.if.lmer.1)

#Relative Cover
txx.rel.cov.lmer.1 = lmer(rel.cov.i.2 ~  txx + SITE_ID + VOR + nr_tran + Action*txx + (1|ObsCode), data = tran.dt)

summary(txx.rel.cov.lmer.1)

#Mean DI
txx.DI.lmer.1 = lmer( meanDI.I_tran ~ txx + SITE_ID + VOR + nr_tran + Action:txx + (1|ObsCode), data = tran.dt)

summary(txx.DI.lmer.1)


###Now with LFE package

#IR
txx.ir.flm.1 = felm(ir_tran ~ Action:txx + txx + ObsCode + VOR + nr_tran | SITE_ID, data = tran.dt,exactDOF='rM')
summary(txx.ir.flm.1, robust = TRUE, cluster = TRUE)

txx.ir.flm.2 = felm(ir_tran ~ Action:txx + txx | TransectID, data = tran.dt,exactDOF='rM') #rank-deficient
summary(txx.ir.flm.2, robust = TRUE, cluster = TRUE)

txx.ir.flm.3 = felm(ir_tran ~ Action:txx + txx | SITE_ID + Year, data = tran.dt,exactDOF='rM') 
summary(txx.ir.flm.3, robust = TRUE, cluster = TRUE)

#Model Diagnostics
qqnorm(residuals(txx.ir.flm.1), ylab = 'Residuals')+
qqline(residuals(txx.ir.flm.1))

#IF
txx.if.flm.1 = felm(if.tran ~ Action:txx + txx + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(txx.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
txx.rel.cov.flm.1 = felm(rel.cov.i.2 ~ Action:txx + txx + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(txx.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
txx.di.flm.1 = felm(meanDI.i.tran.2 ~ Action:txx + txx + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(txx.if.flm.1, robust = TRUE, cluster = TRUE)


```

###Txx Lagged Effects
```{r Invasives-LE-txx}
#IR
tff.ir.lag.lm.1 = lm(ir_tran ~ Action*txx + VOR.lag + nr_tran.lag + ir_tran.lag + ObsCode, data = tran.dt)
summary(tff.ir.lag.lm.1)

#IF
tff.if.lag.lm.1 = lm(if.tran ~ Action*txx + VOR.lag + nr_tran.lag + if.tran.lag + ObsCode, data = tran.dt)
summary(tff.if.lag.lm.1)

#Relative Cover
tff.rc.lag.lm.1 = lm(rel.cov.i.2 ~ Action*txx + VOR.lag + nr_tran.lag + rel.cov.i.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

#DI
tff.DI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*txx + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

```

##Species Level
Instead of looking at the treatment effects on mean invasive abundance, look at the effect on EACH invasive species (can subset this later)

Because the effects will be highly species dependent, we need to consider each species as effectively it's own panel...so 

###Mixed effects
```{r Invasives-ME-TXX}

#With LFE package

#IF
txx.iSf.flm.1 = felm(Freq.T ~ Action:txx + txx + VOR + nr_tran + ObsCode | TransectID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(txx.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
txx.iSrc.flm.1 = felm(rel.cov.T.2 ~ Action:txx + txx + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(txx.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
txx.iSDI.flm.1 = felm(DI.T.2 ~ Action:txx + txx + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(txx.iS.DI.flm.1, robust = TRUE, cluster = TRUE)
```

###Lagged Effects
```{r Invasives-LE-txx}

#IF
txx.iSf.lag.lm.1 = lm(Freq.T ~ Action*txx + VOR.lag + nr_tran.lag + Freq.T.lag + ObsCode, data = i.species.dt)
summary(txx.iSf.lag.lm.1)

#Relative Cover
txx.iSrc.lag.lm.1 = lm(rel.cov.T.2 ~ Action*txx + VOR.lag + nr_tran.lag + rel.cov.T.2.lag + ObsCode, data = i.species.dt)
summary(txx.iSrc.lag.lm.1)

#DI
txx.iSDI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*txx + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = i.species.dt)
summary(txx.iSDI.lag.lm.1)

```



# wsdi 

##Transect

###Basic
```{r Inv-wsdi-basic}

###Explore linear relationship between wsdi and Abundance 

#IR
wsdi.ir.lm.1 = lm(ir_tran ~ 1 + wsdi, data = tran.dt)

summary(wsdi.ir.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.ir.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.ir.lm.1)

#F
wsdi.if.lm.1 = lm(if.tran ~ 1 + wsdi, data = tran.dt)

summary(wsdi.if.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.if.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.if.lm.1)

#Relative Cover
wsdi.rel.cov.lm.1 = lm(rel.cov.i.2 ~ 1 + wsdi, data = tran.dt)

summary(wsdi.rel.cov.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.rel.cov.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.rel.cov.lm.1)

#Mean DI
wsdi.DI.lm.1 = lm( meanDI.i.tran.2 ~ 1 + wsdi, data = tran.dt)

summary(wsdi.DI.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.DI.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.DI.lm.1)



###Add more independent variables to this regression

#IR
wsdi.ir.lm.2 = lm(ir_tran ~ Action + wsdi, data = tran.dt)

summary(wsdi.ir.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.ir.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.ir.lm.2)

#F
wsdi.if.lm.2 = lm(if.tran ~ Action + wsdi, data = tran.dt)

summary(wsdi.if.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.if.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.if.lm.2)

#Relative Cover
wsdi.rel.cov.lm.2 = lm(rel.cov.i.2 ~ Action + wsdi, data = tran.dt)

summary(wsdi.rel.cov.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.rel.cov.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.rel.cov.lm.2)

#Mean DI
wsdi.DI.lm.2 = lm( meanDI.i.tran.2 ~ Action + wsdi, data = tran.dt)

summary(wsdi.DI.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(wsdi.DI.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(wsdi.DI.lm.2)

```

###Mixed effects

```{r inv-wsd-ME}
###LFE Mixed Effects Models

##IR
  #Basic
wsdi.ir.flm.1 = felm(ir_tran ~ Action*wsdi | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.ir.flm.1, robust = TRUE, cluster = TRUE)

  #With additional same year effects
wsdi.ir.flm.2 = felm(ir_tran ~ Action*wsdi + ObsCode + VOR + nr_tran | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.ir.flm.2, robust = TRUE, cluster = TRUE)

  #With lagged effects
wsdi.ir.flm.3 = felm(ir_tran ~ Action*wsdi + ObsCode + VOR + nr_tran + wsdi.lag + prcpt + prcpt.lag | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.ir.flm.3, robust = TRUE, cluster = TRUE)


##IF
  #Basic
wsdi.if.flm.1 = felm(if.tran ~ Action*wsdi | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.1, robust = TRUE, cluster = TRUE)

  #With additional same year effects
wsdi.if.flm.2 = felm(if.tran ~ Action*wsdi + VOR + nr_tran + ObsCode | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.2, robust = TRUE, cluster = TRUE)

  #With lagged effects
wsdi.if.flm.3 = felm(if.tran ~ Action*wsdi  + VOR + nr_tran + ObsCode + wsdi.lag + prcpt + prcpt.lag | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.3, robust = TRUE, cluster = TRUE)

##Relative Cover
  #Basic
wsdi.rc.flm.1 = felm(rel.cov.i.2 ~ Action*wsdi | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.rc.flm.1, robust = TRUE, cluster = TRUE)

  #With additional same year effects
wsdi.rc.flm.2 = felm(rel.cov.i.2 ~ Action*wsdi + VOR + nr_tran + ObsCode | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.rc.flm.2, robust = TRUE, cluster = TRUE)

  #With lagged effects
wsdi.rc.flm.3 = felm(rel.cov.i.2 ~ Action*wsdi + VOR + nr_tran + ObsCode + wsdi.lag + prcpt + prcpt.lag | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.rc.flm.3, robust = TRUE, cluster = TRUE)


##DI
  #Basic
wsdi.di.flm.1 = felm(meanDI.i.tran.2 ~ Action*wsdi | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.1, robust = TRUE, cluster = TRUE)

  #With additional same year effects
wsdi.di.flm.2 = felm(meanDI.i.tran.2 ~ Action*wsdi + VOR + nr_tran + ObsCode | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.2, robust = TRUE, cluster = TRUE)

  #With lagged effects
wsdi.di.flm.3 = felm(meanDI.i.tran.2 ~ Action*wsdi + VOR + nr_tran + ObsCode ++ wsdi.lag + prcpt + prcpt.lag | TransectID, 
                     data = tran.dt,exactDOF='rM')

summary(wsdi.if.flm.3, robust = TRUE, cluster = TRUE)

```

###Lagged Effects
```{r Inv-wsdi-le}
#IR
wsdi.ir.lag.1 = felm(ir_tran ~ Action*wsdi + VOR + nr_tran + ir_tran.lag + ObsCode, data = tran.dt)
summary(wsdi.ir.lag.1)

#IF
wsdi.if.lag.1 = lm(if.tran ~ Action*wsdi + VOR + nr_tran + if.tran.lag + ObsCode, data = tran.dt)
summary(wsdi.if.lag.1)

#Relative Cover
wsdi.rc.lag.1 = lm(rel.cov.i.2 ~ Action*wsdi + VOR + nr_tran + rel.cov.i.2.lag + ObsCode, data = tran.dt)
summary(wsdi.rc.lag.1)

#DI
wsdi.DI.lag.1 = lm(meanDI.i.tran.2 ~ Action*wsdi + VOR + nr_tran + meanDI.i.tran.2.lag + ObsCode, data = tran.dt)
summary(wsdi.DI.lag.1)

```

##Species Level
Instead of looking at the treatment effects on mean invasive abundance, look at the effect on EACH invasive species (can subset this later)

Because the effects will be highly species dependent, we need to consider each species as effectively it's own panel...so 

###Mixed effects
```{r Inv-wsdi-me-sp}
#IF
wsdi.iSf.flm.1 = felm(Freq.T ~ Action*wsdi  + VOR + nr_tran + ObsCode | TransectID + SpeciesID, 
                      data = i.species.dt,exactDOF='rM')

summary(wsdi.iSf.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
wsdi.iSrc.flm.1 = felm(rel.cov.T.2 ~ Action*wsdi + VOR + ObsCode | TransectID + SpeciesID, 
                       data = i.species.dt,exactDOF='rM')

summary(wsdi.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
wsdi.iSDI.flm.1 = felm(DI.T.2 ~ Action*wsdi + VOR + ObsCode | SITE_ID + SpeciesID, 
                       data = i.species.dt,exactDOF='rM')

summary(wsdi.iSDI.flm.1, robust = TRUE, cluster = TRUE)
```

###Lagged effects
```{r Inv-wsdi-le-sp}
#IF
wsdi.iSf.flm.lag.1 = felm(Freq.T ~ Action*wsdi  + VOR + nr_tran + ObsCode | TransectID + SpeciesID, 
                      data = i.species.dt,exactDOF='rM')

summary(wsdi.iSf.flm.lag.1, robust = TRUE, cluster = TRUE)

#Relative Cover
wsdi.iSrc.flm.lag.1 = felm(rel.cov.T.2 ~ Action*wsdi + VOR + ObsCode | TransectID + SpeciesID, 
                       data = i.species.dt,exactDOF='rM')

summary(wsdi.if.flm.lag.1, robust = TRUE, cluster = TRUE)

#DI
wsdi.iSDI.flm.lag.1 = felm(DI.T.2 ~ Action*wsdi + VOR + ObsCode | SITE_ID + SpeciesID, 
                       data = i.species.dt,exactDOF='rM')

summary(wsdi.iSDI.flm.lag.1, robust = TRUE, cluster = TRUE)


```

# TN90p

##Transect

###Mixed effects
```{r Invasives-ME-tn90p}

###Explore linear relationship between tn90p and Abundance 

#IR
tn90p.ir.lm.1 = lm(ir_tran ~ 1 + tn90p, data = tran.dt)

summary(tn90p.ir.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.ir.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.ir.lm.1)

#F
tn90p.if.lm.1 = lm(if.tran ~ 1 + tn90p, data = tran.dt)

summary(tn90p.if.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.if.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.if.lm.1)

#Relative Cover
tn90p.rel.cov.lm.1 = lm(rel.cov.i.2 ~ 1 + tn90p, data = tran.dt)

summary(tn90p.rel.cov.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.rel.cov.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.rel.cov.lm.1)

#Mean DI
tn90p.DI.lm.1 = lm( meanDI.I_tran ~ 1 + tn90p, data = tran.dt)

summary(tn90p.DI.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.DI.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.DI.lm.1)



###Add more independent variables to this regression

#IR
tn90p.ir.lm.2 = lm(ir_tran ~ Action + tn90p, data = tran.dt)

summary(tn90p.ir.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.ir.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.ir.lm.2)

#F
tn90p.if.lm.2 = lm(if.tran ~ Action + tn90p, data = tran.dt)

summary(tn90p.if.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.if.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.if.lm.2)

#Relative Cover
tn90p.rel.cov.lm.2 = lm(rel.cov.i.2 ~ Action + tn90p, data = tran.dt)

summary(tn90p.rel.cov.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.rel.cov.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.rel.cov.lm.2)

#Mean DI
tn90p.DI.lm.2 = lm( meanDI.I_tran ~ Action + tn90p, data = tran.dt)

summary(tn90p.DI.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.DI.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.DI.lm.2)



####Add some interaction to the model

#IR
tn90p.ir.lm.3 = lm(ir_tran ~ Action + tn90p + Action*tn90p, data = tran.dt)

summary(tn90p.ir.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.ir.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.ir.lm.3)

#F
tn90p.if.lm.3 = lm(if.tran ~ Action + tn90p + Action*tn90p, data = tran.dt)

summary(tn90p.if.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.if.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.if.lm.3)

#Relative Cover
tn90p.rel.cov.lm.3 = lm(rel.cov.i.2 ~ Action + tn90p + Action*tn90p, data = tran.dt)

summary(tn90p.rel.cov.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.rel.cov.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.rel.cov.lm.3)

#Mean DI
tn90p.DI.lm.3 = lm( meanDI.I_tran ~ Action + tn90p + Action*tn90p, data = tran.dt)

summary(tn90p.DI.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(tn90p.DI.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(tn90p.DI.lm.3)



#########################Now consider transect as a fixed effect, create a strong global model

#For discussion with Laura...data is limited by years we have climate data for an missing the 2019 data which will give us more years. That being said, there still is not a lot of variabiation in action type - see lines below. I imagine if looked at some sort of management frequency this would be less of an issue.

tran.dt[,length(unique(Year)),by=Action]

tran.dt[,length(unique(Action)),by=Year]

tran.dt[,length(unique(Action)),by=.(Year,SITE_ID)]

#Also, I have not filtered the data to only include transects with two years worth of data. This does not appear to affect the rank deficiency issue

tran.dt[,length(unique(TransectID))]
tran.dt[Delta==1,length(unique(TransectID))] #substantially fewer transects, most of this is a product of incomplete climate data and missing 2019 data

#### First with the Lme4 package

#IR
tn90p.ir.lmer.1 = lmer(ir_tran ~ Action*tn90p + tn90p + VOR + nr_tran + (1|SITE_ID), data = tran.dt)

summary(tn90p.ir.lmer.1)

#F
tn90p.if.lmer.1 = lmer(if.tran ~  tn90p + SITE_ID + VOR + nr_tran + Action*tn90p + (1|ObsCode), data = tran.dt)

summary(tn90p.if.lmer.1)

#Relative Cover
tn90p.rel.cov.lmer.1 = lmer(rel.cov.i.2 ~  tn90p + SITE_ID + VOR + nr_tran + Action*tn90p + (1|ObsCode), data = tran.dt)

summary(tn90p.rel.cov.lmer.1)

#Mean DI
tn90p.DI.lmer.1 = lmer( meanDI.I_tran ~ tn90p + SITE_ID + VOR + nr_tran + Action:tn90p + (1|ObsCode), data = tran.dt)

summary(tn90p.DI.lmer.1)


###Now with LFE package

#IR
tn90p.ir.flm.1 = felm(ir_tran ~ Action:tn90p + tn90p + ObsCode + VOR + nr_tran | SITE_ID, data = tran.dt,exactDOF='rM')
summary(tn90p.ir.flm.1, robust = TRUE, cluster = TRUE)

tn90p.ir.flm.2 = felm(ir_tran ~ Action:tn90p + tn90p | TransectID, data = tran.dt,exactDOF='rM') #rank-deficient
summary(tn90p.ir.flm.2, robust = TRUE, cluster = TRUE)

tn90p.ir.flm.3 = felm(ir_tran ~ Action:tn90p + tn90p | SITE_ID + Year, data = tran.dt,exactDOF='rM') 
summary(tn90p.ir.flm.3, robust = TRUE, cluster = TRUE)

#Model Diagnostics
qqnorm(residuals(tn90p.ir.flm.1), ylab = 'Residuals')+
qqline(residuals(tn90p.ir.flm.1))

#IF
tn90p.if.flm.1 = felm(if.tran ~ Action:tn90p + tn90p + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(tn90p.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
tn90p.rel.cov.flm.1 = felm(rel.cov.i.2 ~ Action:tn90p + tn90p + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(tn90p.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
tn90p.di.flm.1 = felm(meanDI.i.tran.2 ~ Action:tn90p + tn90p + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(tn90p.if.flm.1, robust = TRUE, cluster = TRUE)


```

####tn90p Lagged Effects
```{r Invasives-LE-tn90p}
#IR
tff.ir.lag.lm.1 = lm(ir_tran ~ Action*tn90p + VOR.lag + nr_tran.lag + ir_tran.lag + ObsCode, data = tran.dt)
summary(tff.ir.lag.lm.1)

#IF
tff.if.lag.lm.1 = lm(if.tran ~ Action*tn90p + VOR.lag + nr_tran.lag + if.tran.lag + ObsCode, data = tran.dt)
summary(tff.if.lag.lm.1)

#Relative Cover
tff.rc.lag.lm.1 = lm(rel.cov.i.2 ~ Action*tn90p + VOR.lag + nr_tran.lag + rel.cov.i.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

#DI
tff.DI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*tn90p + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

```

##Species Level
Instead of looking at the treatment effects on mean invasive abundance, look at the effect on EACH invasive species (can subset this later)

Because the effects will be highly species dependent, we need to consider each species as effectively it's own panel...so 

###Mixed effects
```{r Invasives-ME-tn90p}

#With LFE package

#IF
tn90p.iSf.flm.1 = felm(Freq.T ~ Action:tn90p + tn90p + VOR + nr_tran + ObsCode | TransectID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(tn90p.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
tn90p.iSrc.flm.1 = felm(rel.cov.T.2 ~ Action:tn90p + tn90p + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(tn90p.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
tn90p.iSDI.flm.1 = felm(DI.T.2 ~ Action:tn90p + tn90p + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(tn90p.iS.DI.flm.1, robust = TRUE, cluster = TRUE)
```

###Lagged Effects
```{r Invasives-LE-tn90p}

#IF
tn90p.iSf.lag.lm.1 = lm(Freq.T ~ Action*tn90p + VOR.lag + nr_tran.lag + Freq.T.lag + ObsCode, data = i.species.dt)
summary(tn90p.iSf.lag.lm.1)

#Relative Cover
tn90p.iSrc.lag.lm.1 = lm(rel.cov.T.2 ~ Action*tn90p + VOR.lag + nr_tran.lag + rel.cov.T.2.lag + ObsCode, data = i.species.dt)
summary(tn90p.iSrc.lag.lm.1)

#DI
tn90p.iSDI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*tn90p + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = i.species.dt)
summary(tn90p.iSDI.lag.lm.1)

```


# fd



```{r oldmodelcode}

#IR
ind.ir.1 = felm(ir_tran ~ nr_tran.lag + VOR.lag + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = tran.dt, exactDOF='rM')

summary(ind.ir.1,robust = TRUE, cluster = TRUE)

##Hugh run each one with obscode as a random effect

#IF
ind.if.1 = felm(if.tran ~ nr_tran + nr_tran.lag + VOR + VOR.lag + Action +
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = tran.dt)

summary(ind.if.1)

#Relative Cover
ind.irc.1 = felm(rel.cov.i.2 ~ nr_tran + nr_tran.lag + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = tran.dt, exactDOF='rM')

summary(ind.irc.1,robust = TRUE, cluster = TRUE)

#Dominance 
ind.iDI.1 = felm(meanDI.i.tran.2 ~ nr_tran + nr_tran.lag  + Action + 
                          cdd + sdii + gsl + cwd + wsdi + prcpt.lag +
                          Action:gsl + Action:sdii
                | TransectID, data = tran.dt)

summary(ind.iDI.1)



library(texreg)
####### Using texreg for storing model output - examples ######
# Example of texreg with two models - give it a list of models, give titles, etc. Here, for example, these models are called  
my.table = texreg(list(ind.ir.1), 
                    custom.model.names=c("IR Drought Mod"))
#   
#   screenreg(list(clust.res.PlotFEs.SiteYear.Levels,
#                  clust.res.PlotFEs.SiteYear.Levels.groundPAR),       # object with results from clx
#             custom.model.names=c("Base mod", "another mod"),
#             omit.coef=c("(site_code)|(newplotid)"))  # object from estimation (unclustered) for # BIC
#   
#   htmlreg(list(clust.res.PlotFEs.SiteYear.Levels,
#                clust.res.PlotFEs.SiteYear.Levels.groundPAR),       # object with results from clx
#           custom.model.names=c("Base mod", "another mod"),
#           omit.coef=c("(site_code)|(newplotid)"),
#           file="~/Desktop/lauratable.html")

#Plotting
plain <- ggplot(all.results, aes(x = Model, y = Est, fill = Model))



## plain graphic with no data
plain <- ggplot(ind.ir.1, aes(x = Model, y = Est, fill = Model)) +
  geom_bar(stat = "identity", color= "black", position=position_dodge()) +
  ylim(-0.5, 0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black", size = 1.5) +
  geom_errorbar(aes(ymin= Est- (SE*1.96), ymax=Est + (SE*1.96)), width=.2, position=position_dodge(.9)) +  
  theme_bw() +
  theme(axis.text.y = element_text(size = 30, face = "bold")) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme(axis.text.x = element_text(size=30, face = "italic")) + 
  labs(x = "Model", y = "Estimate for log(richness) effect size") +
  theme(axis.title.y= element_text(size=30)) + 
  theme(axis.title.x= element_text(size=30)) +
  labs(title = "Log-Log Model Results") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  theme(plot.title = element_text(face="bold", size = 18))
        
plain + scale_fill_brewer(palette="Greys")
      
## graphic with data for job talk
all.results$Model <- as.factor(all.results$Model)

p_res <- ggplot(all.results, aes(x = Model, y = Est, fill = Model)) +
  geom_bar(stat = "identity", color= "black", 
                    position=position_dodge()) +
           ylim(-0.5, 0.3) +
             geom_hline(yintercept=0, linetype="dashed", color = "black", size = 1.5) +
             geom_errorbar(aes(ymin= Est- (SE*1.96), ymax=Est + (SE*1.96)), width=.2,
                         position=position_dodge(.9)) +  
             theme_bw() +
             theme(axis.text.y = element_text(size = 30, face = "bold")) + 
             theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
             theme(axis.text.x = element_text(size=30, face = "italic")) + 
             labs(x = "Model", y = "Estimate for log(richness) effect size") +
             theme(axis.title.y= element_text(size=30)) + theme(axis.title.x= element_text(size=30)) +
             labs(title = "Log-Log Model Results") + theme(plot.title = element_text(hjust = 0.5)) + 
             theme(plot.title = element_text(face="bold", size = 18))
          
  # p_res + scale_fill_brewer(palette="Greys")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

#model.1 <- "#D55E00"
#p_res +  scale_colour_manual(values = model.1)

p_res + scale_fill_manual(values=cbPalette[c(7,6,1,2)]) +  theme(legend.title=element_text(size=30), legend.text=element_text(size=30))

```



##Transect

###Mixed effects
```{r Invasives-ME-fd}

###Explore linear relationship between fd and Abundance 

#IR
fd.ir.lm.1 = lm(ir_tran ~ 1 + fd, data = tran.dt)

summary(fd.ir.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.ir.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.ir.lm.1)

#F
fd.if.lm.1 = lm(if.tran ~ 1 + fd, data = tran.dt)

summary(fd.if.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.if.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.if.lm.1)

#Relative Cover
fd.rel.cov.lm.1 = lm(rel.cov.i.2 ~ 1 + fd, data = tran.dt)

summary(fd.rel.cov.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.rel.cov.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.rel.cov.lm.1)

#Mean DI
fd.DI.lm.1 = lm( meanDI.I_tran ~ 1 + fd, data = tran.dt)

summary(fd.DI.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.DI.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.DI.lm.1)



###Add more independent variables to this regression

#IR
fd.ir.lm.2 = lm(ir_tran ~ Action + fd, data = tran.dt)

summary(fd.ir.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.ir.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.ir.lm.2)

#F
fd.if.lm.2 = lm(if.tran ~ Action + fd, data = tran.dt)

summary(fd.if.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.if.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.if.lm.2)

#Relative Cover
fd.rel.cov.lm.2 = lm(rel.cov.i.2 ~ Action + fd, data = tran.dt)

summary(fd.rel.cov.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.rel.cov.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.rel.cov.lm.2)

#Mean DI
fd.DI.lm.2 = lm( meanDI.I_tran ~ Action + fd, data = tran.dt)

summary(fd.DI.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.DI.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.DI.lm.2)



####Add some interaction to the model

#IR
fd.ir.lm.3 = lm(ir_tran ~ Action + fd + Action*fd, data = tran.dt)

summary(fd.ir.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.ir.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.ir.lm.3)

#F
fd.if.lm.3 = lm(if.tran ~ Action + fd + Action*fd, data = tran.dt)

summary(fd.if.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.if.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.if.lm.3)

#Relative Cover
fd.rel.cov.lm.3 = lm(rel.cov.i.2 ~ Action + fd + Action*fd, data = tran.dt)

summary(fd.rel.cov.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.rel.cov.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.rel.cov.lm.3)

#Mean DI
fd.DI.lm.3 = lm( meanDI.I_tran ~ Action + fd + Action*fd, data = tran.dt)

summary(fd.DI.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(fd.DI.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(fd.DI.lm.3)



#########################Now consider transect as a fixed effect, create a strong global model

#For discussion with Laura...data is limited by years we have climate data for an missing the 2019 data which will give us more years. That being said, there still is not a lot of variabiation in action type - see lines below. I imagine if looked at some sort of management frequency this would be less of an issue.

tran.dt[,length(unique(Year)),by=Action]

tran.dt[,length(unique(Action)),by=Year]

tran.dt[,length(unique(Action)),by=.(Year,SITE_ID)]

#Also, I have not filtered the data to only include transects with two years worth of data. This does not appear to affect the rank deficiency issue

tran.dt[,length(unique(TransectID))]
tran.dt[Delta==1,length(unique(TransectID))] #substantially fewer transects, most of this is a product of incomplete climate data and missing 2019 data

#### First with the Lme4 package

#IR
fd.ir.lmer.1 = lmer(ir_tran ~ Action*fd + fd + VOR + nr_tran + (1|SITE_ID), data = tran.dt)

summary(fd.ir.lmer.1)

#F
fd.if.lmer.1 = lmer(if.tran ~  fd + SITE_ID + VOR + nr_tran + Action*fd + (1|ObsCode), data = tran.dt)

summary(fd.if.lmer.1)

#Relative Cover
fd.rel.cov.lmer.1 = lmer(rel.cov.i.2 ~  fd + SITE_ID + VOR + nr_tran + Action*fd + (1|ObsCode), data = tran.dt)

summary(fd.rel.cov.lmer.1)

#Mean DI
fd.DI.lmer.1 = lmer( meanDI.I_tran ~ fd + SITE_ID + VOR + nr_tran + Action:fd + (1|ObsCode), data = tran.dt)

summary(fd.DI.lmer.1)


###Now with LFE package

#IR
fd.ir.flm.1 = felm(ir_tran ~ Action:fd + fd + ObsCode + VOR + nr_tran | SITE_ID, data = tran.dt,exactDOF='rM')
summary(fd.ir.flm.1, robust = TRUE, cluster = TRUE)

fd.ir.flm.2 = felm(ir_tran ~ Action:fd + fd | TransectID, data = tran.dt,exactDOF='rM') #rank-deficient
summary(fd.ir.flm.2, robust = TRUE, cluster = TRUE)

fd.ir.flm.3 = felm(ir_tran ~ Action:fd + fd | SITE_ID + Year, data = tran.dt,exactDOF='rM') 
summary(fd.ir.flm.3, robust = TRUE, cluster = TRUE)

#Model Diagnostics
qqnorm(residuals(fd.ir.flm.1), ylab = 'Residuals')+
qqline(residuals(fd.ir.flm.1))

#IF
fd.if.flm.1 = felm(if.tran ~ Action:fd + fd + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(fd.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
fd.rel.cov.flm.1 = felm(rel.cov.i.2 ~ Action:fd + fd + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(fd.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
fd.di.flm.1 = felm(meanDI.i.tran.2 ~ Action:fd + fd + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(fd.if.flm.1, robust = TRUE, cluster = TRUE)


```

####fd Lagged Effects
```{r Invasives-LE-fd}
#IR
tff.ir.lag.lm.1 = lm(ir_tran ~ Action*fd + VOR.lag + nr_tran.lag + ir_tran.lag + ObsCode, data = tran.dt)
summary(tff.ir.lag.lm.1)

#IF
tff.if.lag.lm.1 = lm(if.tran ~ Action*fd + VOR.lag + nr_tran.lag + if.tran.lag + ObsCode, data = tran.dt)
summary(tff.if.lag.lm.1)

#Relative Cover
tff.rc.lag.lm.1 = lm(rel.cov.i.2 ~ Action*fd + VOR.lag + nr_tran.lag + rel.cov.i.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

#DI
tff.DI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*fd + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

```

##Species Level
Instead of looking at the treatment effects on mean invasive abundance, look at the effect on EACH invasive species (can subset this later)

Because the effects will be highly species dependent, we need to consider each species as effectively it's own panel...so 

###Mixed effects
```{r Invasives-ME-fd}

#With LFE package

#IF
fd.iSf.flm.1 = felm(Freq.T ~ Action:fd + fd + VOR + nr_tran + ObsCode | TransectID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(fd.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
fd.iSrc.flm.1 = felm(rel.cov.T.2 ~ Action:fd + fd + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(fd.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
fd.iSDI.flm.1 = felm(DI.T.2 ~ Action:fd + fd + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(fd.iS.DI.flm.1, robust = TRUE, cluster = TRUE)
```

###Lagged Effects
```{r Invasives-LE-fd}

#IF
fd.iSf.lag.lm.1 = lm(Freq.T ~ Action*fd + VOR.lag + nr_tran.lag + Freq.T.lag + ObsCode, data = i.species.dt)
summary(fd.iSf.lag.lm.1)

#Relative Cover
fd.iSrc.lag.lm.1 = lm(rel.cov.T.2 ~ Action*fd + VOR.lag + nr_tran.lag + rel.cov.T.2.lag + ObsCode, data = i.species.dt)
summary(fd.iSrc.lag.lm.1)

#DI
fd.iSDI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*fd + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = i.species.dt)
summary(fd.iSDI.lag.lm.1)

```


# gsl

##Transect

###Mixed effects
```{r Invasives-ME-gsl}

###Explore linear relationship between gsl and Abundance 

#IR
gsl.ir.lm.1 = lm(ir_tran ~ 1 + gsl, data = tran.dt)

summary(gsl.ir.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.ir.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.ir.lm.1)

#F
gsl.if.lm.1 = lm(if.tran ~ 1 + gsl, data = tran.dt)

summary(gsl.if.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.if.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.if.lm.1)

#Relative Cover
gsl.rel.cov.lm.1 = lm(rel.cov.i.2 ~ 1 + gsl, data = tran.dt)

summary(gsl.rel.cov.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.rel.cov.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.rel.cov.lm.1)

#Mean DI
gsl.DI.lm.1 = lm( meanDI.I.tran.2 ~ 1 + gsl, data = tran.dt)

summary(gsl.DI.lm.1)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.DI.lm.1)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.DI.lm.1)



###Add more independent variables to this regression

#IR
gsl.ir.lm.2 = lm(ir_tran ~ Action + gsl, data = tran.dt)

summary(gsl.ir.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.ir.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.ir.lm.2)

#F
gsl.if.lm.2 = lm(if.tran ~ Action + gsl, data = tran.dt)

summary(gsl.if.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.if.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.if.lm.2)

#Relative Cover
gsl.rel.cov.lm.2 = lm(rel.cov.i.2 ~ Action + gsl, data = tran.dt)

summary(gsl.rel.cov.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.rel.cov.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.rel.cov.lm.2)

#Mean DI
gsl.DI.lm.2 = lm( meanDI.I.tran.2 ~ Action + gsl, data = tran.dt)

summary(gsl.DI.lm.2)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.DI.lm.2)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.DI.lm.2)



####Add some interaction to the model

#IR
gsl.ir.lm.3 = lm(ir_tran ~ Action + gsl + Action*gsl, data = tran.dt)

summary(gsl.ir.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.ir.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.ir.lm.3)

#F
gsl.if.lm.3 = lm(if.tran ~ Action + gsl + Action*gsl, data = tran.dt)

summary(gsl.if.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.if.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.if.lm.3)

#Relative Cover
gsl.rel.cov.lm.3 = lm(rel.cov.i.2 ~ Action + gsl + Action*gsl, data = tran.dt)

summary(gsl.rel.cov.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.rel.cov.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.rel.cov.lm.3)

#Mean DI
gsl.DI.lm.3 = lm( meanDI.I.tran.2 ~ Action + gsl + Action*gsl, data = tran.dt)

summary(gsl.DI.lm.3)

par(mfrow=c(2,2)) # Change the panel layout to 2 x 2
plot(gsl.DI.lm.3)
par(mfrow=c(1,1)) # Change back to 1 x 1

AIC(gsl.DI.lm.3)



#########################Now consider transect as a fixed effect, create a strong global model


#IR
gsl.ir.lmer.1 = lmer(ir_tran ~ Action*gsl + gsl + VOR + nr_tran + (1|SITE_ID), data = tran.dt)

summary(gsl.ir.lmer.1)

#F
gsl.if.lmer.1 = lmer(if.tran ~  gsl + SITE_ID + VOR + nr_tran + Action*gsl + (1|ObsCode), data = tran.dt)

summary(gsl.if.lmer.1)

#Relative Cover
gsl.rel.cov.lmer.1 = lmer(rel.cov.i.2 ~  gsl + SITE_ID + VOR + nr_tran + Action*gsl + (1|ObsCode), data = tran.dt)

summary(gsl.rel.cov.lmer.1)

#Mean DI
gsl.DI.lmer.1 = lmer( meanDI.I.tran.2 ~ gsl + SITE_ID + VOR + nr_tran + Action:gsl + (1|ObsCode), data = tran.dt)

summary(gsl.DI.lmer.1)


###Now with LFE package

#IR
gsl.ir.flm.1 = felm(ir_tran ~ Action:gsl + gsl + ObsCode + VOR + nr_tran | SITE_ID, data = tran.dt,exactDOF='rM')
summary(gsl.ir.flm.1, robust = TRUE, cluster = TRUE)

gsl.ir.flm.2 = felm(ir_tran ~ Action:gsl + gsl | TransectID, data = tran.dt,exactDOF='rM') #rank-deficient
summary(gsl.ir.flm.2, robust = TRUE, cluster = TRUE)

gsl.ir.flm.3 = felm(ir_tran ~ Action:gsl + gsl | SITE_ID + Year, data = tran.dt,exactDOF='rM') 
summary(gsl.ir.flm.3, robust = TRUE, cluster = TRUE)

#Model Diagnostics
qqnorm(residuals(gsl.ir.flm.1), ylab = 'Residuals')+
qqline(residuals(gsl.ir.flm.1))

#IF
gsl.if.flm.1 = felm(if.tran ~ Action:gsl + gsl + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(gsl.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
gsl.rel.cov.flm.1 = felm(rel.cov.i.2 ~ Action:gsl + gsl + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(gsl.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
gsl.di.flm.1 = felm(meanDI.i.tran.2 ~ Action:gsl + gsl + VOR + nr_tran + ObsCode | SITE_ID, data = tran.dt,exactDOF='rM')
summary(gsl.if.flm.1, robust = TRUE, cluster = TRUE)


```

####gsl Lagged Effects
```{r Invasives-LE-gsl}
#IR
tff.ir.lag.lm.1 = lm(ir_tran ~ Action*gsl + VOR.lag + nr_tran.lag + ir_tran.lag + ObsCode, data = tran.dt)
summary(tff.ir.lag.lm.1)

#IF
tff.if.lag.lm.1 = lm(if.tran ~ Action*gsl + VOR.lag + nr_tran.lag + if.tran.lag + ObsCode, data = tran.dt)
summary(tff.if.lag.lm.1)

#Relative Cover
tff.rc.lag.lm.1 = lm(rel.cov.i.2 ~ Action*gsl + VOR.lag + nr_tran.lag + rel.cov.i.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

#DI
tff.DI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*gsl + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = tran.dt)
summary(tff.rc.lag.lm.1)

```

##Species Level
Instead of looking at the treatment effects on mean invasive abundance, look at the effect on EACH invasive species (can subset this later)

Because the effects will be highly species dependent, we need to consider each species as effectively it's own panel...so 

###Mixed effects
```{r Invasives-ME-gsl}

#With LFE package

#IF
gsl.iSf.flm.1 = felm(Freq.T ~ Action:gsl + gsl + VOR + nr_tran + ObsCode | TransectID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(gsl.if.flm.1, robust = TRUE, cluster = TRUE)

#Relative Cover
gsl.iSrc.flm.1 = felm(rel.cov.T.2 ~ Action:gsl + gsl + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(gsl.if.flm.1, robust = TRUE, cluster = TRUE)

#DI
gsl.iSDI.flm.1 = felm(DI.T.2 ~ Action:gsl + gsl + VOR + ObsCode | SITE_ID + SpeciesID, data = i.species.dt,exactDOF='rM')
summary(gsl.iS.DI.flm.1, robust = TRUE, cluster = TRUE)
```

###Lagged Effects
```{r Invasives-LE-gsl}

#IF
gsl.iSf.lag.lm.1 = lm(Freq.T ~ Action*gsl + VOR.lag + nr_tran.lag + Freq.T.lag + ObsCode, data = i.species.dt)
summary(gsl.iSf.lag.lm.1)

#Relative Cover
gsl.iSrc.lag.lm.1 = lm(rel.cov.T.2 ~ Action*gsl + VOR.lag + nr_tran.lag + rel.cov.T.2.lag + ObsCode, data = i.species.dt)
summary(gsl.iSrc.lag.lm.1)

#DI
gsl.iSDI.lag.lm.1 = lm(meanDI.i.tran.2 ~ Action*gsl + VOR.lag + nr_tran.lag + meanDI.i.tran.2.lag + ObsCode, data = i.species.dt)
summary(gsl.iSDI.lag.lm.1)

```



